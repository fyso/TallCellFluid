#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel markParticleByCellType
#pragma kernel gatherGridToParticle
#pragma kernel scatterOnlyTallCellParticleToGrid
#pragma kernel gatherOnlyTallCellParticleToGrid
#pragma use_dxc

uint ParticleCountOffset;

StructuredBuffer<int> ParticleIndrectArgment_R;

StructuredBuffer<float3> ParticlePosition_R;
StructuredBuffer<float3> ParticleVelocity_R;
StructuredBuffer<uint> ParticleFilter_R;
RWStructuredBuffer<float3> ParticleVelocity_RW;
RWStructuredBuffer<uint> ParticleFilter_RW;
StructuredBuffer<uint> HashGridCellParticleCount_R;
StructuredBuffer<uint> HashGridCellParticleOffset_R;
Texture2D<float> TerrianHeight_R;
Texture2D<float> TallCellHeight_R;

Texture3D<float3> RegularCellVelocity_R;
Texture2D<float3> TopCellVelocity_R;
Texture2D<float3> BottomCellVelocity_R;
RWTexture3D<float3> RegularCellVelocity_RW;
RWTexture2D<float3> TopCellVelocity_RW;
RWTexture2D<float3> BottomCellVelocity_RW;

const int2 OffsetVector2D[3 * 3] =
{
    { -1, 0 },
    { 1, 0 },
    { 0, -1 },
    { 0, 1 },
    { 1, 1 },
    { -1, -1 },
    { -1, 1 },
    { 1, -1 },
    { 0, 0 }
};

const int3 OffsetVector3D[3 * 3 * 3] =
{
    { -1, 0, 0},
    { 1, 0, 0 },
    { 0, -1, 0 },
    { 0, 1, 0 },
    { 1, 1, 0 },
    { -1, -1, 0 },
    { -1, 1, 0 },
    { 1, -1, 0 },
    { 0, 0, 0 },
    
    { -1, 0, 1 },
    { 1, 0, 1 },
    { 0, -1, 1 },
    { 0, 1, 1 },
    { 1, 1, 1 },
    { -1, -1, 1 },
    { -1, 1, 1 },
    { 1, -1, 1 },
    { 0, 0, 1 },
    
    { -1, 0, -1 },
    { 1, 0, -1 },
    { 0, -1, -1 },
    { 0, 1, -1 },
    { 1, 1, -1 },
    { -1, -1, -1 },
    { -1, 1, -1 },
    { 1, -1, -1 },
    { 0, 0, -1 }
};

[numthreads(THREAD_COUNT_1D, 1, 1)]
void markParticleByCellType(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    
    float CenterTerrianHeight = TerrianHeight_R[CurrGridXZIndex];
    float CenterTallCellHeight = TallCellHeight_R[CurrGridXZIndex];
    
    bool IsInTerrianCell = false;
    bool IsInTallCell = false;
    bool IsAnyTallCellHigher = false;
    bool IsAnyTallCellLower = false;
    
    if (RelativeHeight < CenterTerrianHeight)
        IsInTerrianCell = true;
    
    if (RelativeHeight < CenterTerrianHeight + CenterTallCellHeight && RelativeHeight >= CenterTerrianHeight)
        IsInTallCell = true;
    
    for (int c = 0; c < 3 * 3 - 1; c++)
    {
        float SurroundTerrianHeight = TerrianHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        float SurroundTallCellHeight = TallCellHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        
        if (RelativeHeight < SurroundTallCellHeight + SurroundTerrianHeight + CellLength)
        {
            IsAnyTallCellHigher = true;
        }
        
        if (RelativeHeight > SurroundTallCellHeight + SurroundTerrianHeight - CellLength)
        {
            IsAnyTallCellLower = true;
        }
    }
    
    if (!IsInTallCell && !IsInTerrianCell)
    {
        if (IsAnyTallCellHigher)
            ParticleFilter_RW[i] = 1;
        else
            ParticleFilter_RW[i] = 0;
    }
    else if (IsInTallCell)
    {
        if (!IsAnyTallCellLower)
            ParticleFilter_RW[i] = 3;
        else
            ParticleFilter_RW[i] = 1;
    }
    else
    {
        ParticleFilter_RW[i] = 4;
    }
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void gatherGridToParticle(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    uint CurrGridYIndex = RelativeHeight / CellLength;
    
    float3 CurrCenterCellPosition = float3(CurrGridXZIndex.x + 0.5f, CurrGridYIndex + 0.5f, CurrGridXZIndex.y + 0.5f) * CellLength;
    float WeightSum = 0.0f;
    float3 WeightValue = float3(0, 0, 0);
    for (int c = 0; c < 3 * 3 * 3; c++)
    {
        uint2 AdjXZ = CurrGridXZIndex + OffsetVector3D[c].xz;
        float CenterTerrianHeight = TerrianHeight_R[AdjXZ];
        float CenterTallCellHeight = TallCellHeight_R[AdjXZ];
        
        float3 AdjPoint = CurrCenterCellPosition + OffsetVector3D[c] * CellLength;
        float Weight = CubicKernel(length(AdjPoint - CurrCenterCellPosition) / CellLength);
        
        float3 Value = float3(0, 0, 0);
        if (AdjPoint.y >= CenterTerrianHeight + CenterTallCellHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight + ConstantCellNum * CellLength)
        {
            uint YIndex = (AdjPoint.y - 0.5f * CellLength - CenterTerrianHeight - CenterTallCellHeight) / CellLength;
            Value = RegularCellVelocity_R[uint3(AdjXZ.x, YIndex, AdjXZ.y)];
        }
        else
        {
            Value = float3(0, 0, 0);
        }
        WeightValue += Value * Weight;
        WeightSum += Weight;
    }
    
    for (c = 0; c < 3 * 3; c++)
    {
        uint2 AdjXZ = CurrGridXZIndex + OffsetVector2D[c];
        float CenterTerrianHeight = TerrianHeight_R[AdjXZ];
        float CenterTallCellHeight = TallCellHeight_R[AdjXZ];
        
        float3 AdjPoint = CurrPosition + float3(OffsetVector2D[c].x, 0, OffsetVector2D[c].y) * CellLength;
        float Weight = CubicKernel(length(AdjPoint - CurrCenterCellPosition) / CellLength);
        
        float3 Value = float3(0, 0, 0);
        if (AdjPoint.y >= CenterTerrianHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight)
        {
            float3 TopValue = TopCellVelocity_R[AdjXZ];
            float3 BottomValue = BottomCellVelocity_R[AdjXZ];
            float RelativeHeight = (AdjPoint.y - (CenterTerrianHeight + 0.5f * CellLength)) / (CenterTallCellHeight - CellLength);
            Value = RelativeHeight * TopValue + (1.0f - RelativeHeight) * BottomValue;
        }
        WeightValue += Value * Weight;
        WeightSum += Weight;
    }
    
    ParticleVelocity_RW[i] = WeightValue / WeightSum;
}

groupshared int LocalTallCellIndex[THREAD_COUNT_1D];
groupshared float LocalX[THREAD_COUNT_1D];
groupshared float3 LocalY[THREAD_COUNT_1D];
groupshared uint LocalMark[THREAD_COUNT_1D / 32];
[numthreads(THREAD_COUNT_1D, 1, 1)]
void scatterOnlyTallCellParticleToGrid(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrVelocity = ParticleVelocity_R[i];
    LocalY[ThreadIdx] = CurrVelocity;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    LocalX[ThreadIdx] = RelativeHeight;
    
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    uint CurrTallCellLinerIndex = computeMorton2D(RelativeXZ / CellLength);
    LocalTallCellIndex[ThreadIdx] = CurrTallCellLinerIndex;
    
    GroupMemoryBarrierWithGroupSync();
    
    uint PrevTallCellLinerIndex = ThreadIdx == 0 ? 0 : LocalTallCellIndex[ThreadIdx - 1];
    bool MaskBit =  ThreadIdx == 0 || PrevTallCellLinerIndex != CurrTallCellLinerIndex;
    uint Mask = ((uint) MaskBit) << (ThreadIdx % 32);
    LocalMark[ThreadIdx / 32] |= Mask;
    GroupMemoryBarrierWithGroupSync();
    
    //calculate current block XSum, YSum, XXSum, XYSum
    
    
    //interlocked to global memory
    if(MaskBit)
    {
        //scale sum for each adjective tall cell
        for (int c = 0; c < 3 * 3; c++)
        {
            uint2 AdjTallCell2DIndex = CurrGridXZIndex + OffsetVector2D[c];
            
        }
    }
}

//TODO: we can use sort and warp-level perfixsum to discard many interlocked operation
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void gatherOnlyTallCellParticleToGrid(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float XSum = 0;
    float3 YSum = 0;
    float XXSum = 0;
    float3 XYSum = 0;
    uint M = 0;
    for (int c = 0; c < 9; c++)
    {
        int2 CurrOffset = OffsetVector2D[c];
        uint2 AdjTallCell2DIndex = DispatchThreadID.xy + CurrOffset;
        
        if (any(AdjTallCell2DIndex < 0) || any(AdjTallCell2DIndex >= XZResolution))
            continue;

        uint AdjTallCellLinerIndex = computeMorton2D(AdjTallCell2DIndex);
        uint IntraParticleCount = HashGridCellParticleCount_R[AdjTallCellLinerIndex];
        uint IntraParticleOffset = HashGridCellParticleOffset_R[AdjTallCellLinerIndex];
        for (int k = 0; k < IntraParticleCount; k++)
        {
            float3 CurrParticlePos = ParticlePosition_R[IntraParticleOffset + k];
            float3 CurrParticleVel = ParticleVelocity_R[IntraParticleOffset + k];
            float3 CenterCellPos = floor((CurrParticlePos - Min) / CellLength) * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
            float2 ContributePointXZ = CenterCellPos.xz - CurrOffset * CellLength;
            
            float Weight = CubicKernel(length(ContributePointXZ - CurrParticlePos.xz) / CellLength);
            float3 Y = Weight * CurrParticleVel;
            float X = CurrParticlePos.y - Min.y;
            XSum += X;
            YSum += Y;
            XXSum += pow(X, 2);
            XYSum += X * Y;
        }
        M += IntraParticleCount;
    }
    
    float3 Sigma0 = (XXSum * YSum - XSum * XYSum) / (M * XXSum - pow(XSum, 2));
    float3 Sigma1 = (M * XYSum - XSum * YSum) / (M * XXSum - pow(XSum, 2));
    
    float CenterTerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float CenterTallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    float3 TopValue = Sigma0 + Sigma1 * (CenterTallCellHeight - 0.5f * CellLength);
    float3 BottomValue = Sigma0 + Sigma1 * 0.5f * CellLength;
    
    TopCellVelocity_RW[DispatchThreadID.xy] = TopValue;
    BottomCellVelocity_RW[DispatchThreadID.xy] = BottomValue;
}