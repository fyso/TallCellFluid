#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel markParticleByCellType
#pragma kernel gatherGridToParticle
#pragma kernel scatterOnlyTallCellParticleToGrid_Pass1
#pragma kernel scatterOnlyTallCellParticleToGrid_Pass2
#pragma kernel scatterRegularParticleToGrid_Pass1
#pragma kernel scatterRegularParticleToGrid_Pass2
#pragma use_dxc

uint ParticleCountArgumentOffset;
uint DifferParticleSplitPointArgumentOffset;
uint DifferParticleCountArgumentOffset;
uint OnlyTallCellParticleType;
uint OnlyRegularCellParticleType;

RWStructuredBuffer<float3> DEBUG;

StructuredBuffer<int> ParticleIndrectArgment_R;

StructuredBuffer<float3> ParticlePosition_R;

StructuredBuffer<float3> ParticleVelocity_R;
RWStructuredBuffer<float3> ParticleVelocity_RW;

Texture2D<float> TerrianHeight_R;
Texture2D<float> TallCellHeight_R;

Texture3D<float3> RegularCellVelocity_R;
RWTexture3D<float3> RegularCellVelocity_RW;
Texture2D<float3> TopCellVelocity_R;
RWTexture2D<float3> TopCellVelocity_RW;
Texture2D<float3> BottomCellVelocity_R;
RWTexture2D<float3> BottomCellVelocity_RW;

StructuredBuffer<uint> ParticleFilter_R;
RWStructuredBuffer<uint> ParticleFilter_RW;

int2 OffsetVector2D[3 * 3] =
{
    { -1, 0 },
    { 1, 0 },
    { 0, -1 },
    { 0, 1 },
    { 1, 1 },
    { -1, -1 },
    { -1, 1 },
    { 1, -1 },
    { 0, 0 }
};

int3 OffsetVector3D[3 * 3 * 3] =
{
    { -1, 0, 0},
    { 1, 0, 0 },
    { 0, -1, 0 },
    { 0, 1, 0 },
    { 1, 1, 0 },
    { -1, -1, 0 },
    { -1, 1, 0 },
    { 1, -1, 0 },
    { 0, 0, 0 },
    
    { -1, 0, 1 },
    { 1, 0, 1 },
    { 0, -1, 1 },
    { 0, 1, 1 },
    { 1, 1, 1 },
    { -1, -1, 1 },
    { -1, 1, 1 },
    { 1, -1, 1 },
    { 0, 0, 1 },
    
    { -1, 0, -1 },
    { 1, 0, -1 },
    { 0, -1, -1 },
    { 0, 1, -1 },
    { 1, 1, -1 },
    { -1, -1, -1 },
    { -1, 1, -1 },
    { 1, -1, -1 },
    { 0, 0, -1 }
};

[numthreads(THREAD_COUNT_1D, 1, 1)]
void markParticleByCellType(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountArgumentOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    
    float CenterTerrianHeight = TerrianHeight_R[CurrGridXZIndex];
    float CenterTallCellHeight = TallCellHeight_R[CurrGridXZIndex];
    
    bool IsInTerrianCell = false;
    bool IsInTallCell = false;
    bool IsAnyTallCellHigher = false;
    bool IsAnyTallCellLower = false;
    
    if (RelativeHeight < CenterTerrianHeight)
        IsInTerrianCell = true;
    
    if (RelativeHeight < CenterTerrianHeight + CenterTallCellHeight && RelativeHeight >= CenterTerrianHeight)
        IsInTallCell = true;
    
    for (int c = 0; c < 3 * 3 - 1; c++)
    {
        float SurroundTerrianHeight = TerrianHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        float SurroundTallCellHeight = TallCellHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        
        if (RelativeHeight <= SurroundTallCellHeight + SurroundTerrianHeight + CellLength)
        {
            IsAnyTallCellHigher = true;
        }
        
        if (RelativeHeight >= SurroundTallCellHeight + SurroundTerrianHeight - CellLength)
        {
            IsAnyTallCellLower = true;
        }
    }
    
    if (!IsInTallCell && !IsInTerrianCell)
    {
        if (!IsAnyTallCellHigher)
            ParticleFilter_RW[i] = 0;
        else
            ParticleFilter_RW[i] = 1;
    }
    else if (IsInTallCell && !IsInTerrianCell)
    {
        if (!IsAnyTallCellLower)
            ParticleFilter_RW[i] = 3;
        else
            ParticleFilter_RW[i] = 2;
    }
    else
    {
        ParticleFilter_RW[i] = 4;
    }
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void gatherGridToParticle(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountArgumentOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    uint CurrFilter = ParticleFilter_R[i];
    if(CurrFilter != OnlyTallCellParticleType && CurrFilter != OnlyRegularCellParticleType)
        return;
    
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    float RelativeY = CurrPosition.y - Min.y;
    float3 RelativePosition = float3(RelativeXZ.x, RelativeY, RelativeXZ.y);
    
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    uint CurrGridYIndex = RelativePosition.y / CellLength;
    uint3 CurrCenterCell3DIndex = uint3(CurrGridXZIndex.x, CurrGridYIndex, CurrGridXZIndex.y);
    float3 CurrCenterCellPosition = CurrCenterCell3DIndex * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
    
    float WeightSum = 0.0f;
    float3 WeightValue = float3(0, 0, 0);
    for (int c = 0; c < 3 * 3 * 3; c++)
    {
        float3 AdjPoint = CurrCenterCellPosition + OffsetVector3D[c] * CellLength;
        int2 AdjXZ = AdjPoint.xz / CellLength;
        
        if (any(AdjXZ < 0) || any(AdjXZ >= XZResolution))
            continue;
        
        float Weight = CubicKernel(length(AdjPoint - CurrPosition) / CellLength);
        float CenterTerrianHeight = TerrianHeight_R[AdjXZ];
        float CenterTallCellHeight = TallCellHeight_R[AdjXZ];
        float3 Value = float3(0, 0, 0);
        if (AdjPoint.y >= CenterTerrianHeight + CenterTallCellHeight - CellLength && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight + ConstantCellNum * CellLength)
        {
            uint YIndex = (AdjPoint.y - CenterTerrianHeight - CenterTallCellHeight) / CellLength;
            Value = RegularCellVelocity_R[uint3(AdjXZ.x, YIndex, AdjXZ.y)];
        }
        else if (AdjPoint.y >= CenterTerrianHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight - CellLength)
        {
            float3 TopValue = TopCellVelocity_R[AdjXZ];
            float3 BottomValue = BottomCellVelocity_R[AdjXZ];
            float RelativeHeight = (AdjPoint.y - CenterTerrianHeight - 0.5f * CellLength) / ((CenterTallCellHeight - CellLength));
            Value = RelativeHeight * (TopValue - BottomValue) + BottomValue;
        }
        else
        {
            Value = float3(0, 0, 0);
            Weight = 0;
        }
        WeightValue += Value * Weight;
        WeightSum += Weight;
    }
    
    for (c = 0; c < 3 * 3; c++)
    {
        float2 AdjPointXZ = CurrCenterCellPosition.xz + OffsetVector2D[c] * CellLength;
        float3 AdjPoint = float3(AdjPointXZ.x, RelativePosition.y, AdjPointXZ.y);
        int2 AdjXZ = AdjPoint.xz / CellLength;
        if (any(AdjXZ < 0) || any(AdjXZ >= XZResolution))
            continue;
        float CenterTerrianHeight = TerrianHeight_R[AdjXZ];
        float CenterTallCellHeight = TallCellHeight_R[AdjXZ];
        float Weight = CubicKernel(length(AdjPoint - CurrPosition) / CellLength);
        float3 Value = float3(0, 0, 0);
        if (AdjPoint.y >= CenterTerrianHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight)
        {
            float3 TopValue = TopCellVelocity_R[AdjXZ];
            float3 BottomValue = BottomCellVelocity_R[AdjXZ];
            float RelativeHeight = (AdjPoint.y - CenterTerrianHeight - 0.5f * CellLength) / ((CenterTallCellHeight - CellLength));
            Value = RelativeHeight * (TopValue - BottomValue) + BottomValue;
        }
        else
        {
            Value = float3(0, 0, 0);
            Weight = 0;
        }
        WeightValue += Value * Weight;
        WeightSum += Weight;
    }
    
    float3 FinalValue = float3(0, 0, 0);
    if (WeightSum != 0)
        FinalValue = WeightValue / WeightSum;
    ParticleVelocity_RW[i] = FinalValue;
}

uint doCLZLowToHigh(uint4 vInput, uint vTargetBit)
{
    uint Result = 0;
    
    uint Index = vTargetBit / 32;
    uint Offset = vTargetBit % 32;
    
    for (int c = Index; c < 4; c++)
    {
        if (c == Index)
            vInput[c] &= ~(0xFFFFFFFF >> (32 - Offset - 1));
        
        uint FirstIndex = firstbitlow(vInput[c]);
        if (FirstIndex != 0xFFFFFFFF)
        {
            Result += FirstIndex - Offset - 1;
            break;
        }
        else
        {
            Result += 32 - Offset - 1;
            Offset = -1;
        }
    }
    return Result;
}

uint doCLZHighToLow(uint4 vInput, uint vTargetBit)
{
    uint Result = 0;
    
    uint Index = vTargetBit / 32;
    uint Offset = vTargetBit % 32;
    
    for (int c = Index; c >= 0; c--)
    {
        if (c == Index)
            vInput[c] &= ~((0xFFFFFFFF >> Offset) << Offset);
        
        uint FirstIndex = firstbithigh(vInput[c]);
        if (FirstIndex != 0xFFFFFFFF)
        {
            Result += Offset - FirstIndex - 1;
            break;
        }
        else
        {
            Result += Offset;
            Offset = 32;
        }
    }
    return Result;
}

uint4 MaskUnusedBit(uint4 vInput, uint vLaneCount)
{
    uint Index = vLaneCount / 32;
    uint Offset = vLaneCount % 32;
    vInput[Index] |= (0xFFFFFFFF << Offset);
    for (int c = Index + 1; c < 4; c++)
    {
        vInput[Index] |= 0xFFFFFFFF;
    }
    return vInput;
}

#define ZIP 1000000
Texture2D<uint> ParticleCount_R;
Texture3D<int> XSum_R;
Texture3D<int> XXSum_R;
Texture3D<int> YSum_R;
Texture3D<int> XYSum_R;

RWTexture2D<uint> ParticleCount_RW;
RWTexture3D<int> XSum_RW;
RWTexture3D<int> XXSum_RW;
RWTexture3D<int> YSum_RW;
RWTexture3D<int> XYSum_RW;

groupshared float LocalWeight[THREAD_COUNT_1D];
groupshared float3 LocalWeightedVelocity[THREAD_COUNT_1D];

[numthreads(THREAD_COUNT_1D, 1, 1)]
void scatterOnlyTallCellParticleToGrid_Pass1(uint ThreadIdx : SV_GroupIndex, uint3 GroupIdx : SV_GroupID)
{
    uint CurrLaneIndex = WaveGetLaneIndex();
    uint CurrLaneCount = WaveGetLaneCount();
    uint CurrWarpIndex = ThreadIdx / CurrLaneCount;
    
    uint Count = ParticleIndrectArgment_R[DifferParticleCountArgumentOffset + OnlyTallCellParticleType];
    uint Offset = OnlyTallCellParticleType == 0 ? 0 : ParticleIndrectArgment_R[DifferParticleSplitPointArgumentOffset + OnlyTallCellParticleType - 1];
    uint i = Offset + ThreadIdx + GroupIdx.x * THREAD_COUNT_1D;
    if (i - Offset >= Count)
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float3 CurrVelocity = ParticleVelocity_R[i];
    
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    float RelativeY = CurrPosition.y - Min.y;
    float3 RelativePosition = float3(RelativeXZ.x, RelativeY, RelativeXZ.y);
    
    uint2 CurrGridXZIndex = RelativePosition.xz / CellLength;
    uint CurrGridYIndex = RelativePosition.y / CellLength;
    uint3 CurrCenterCell3DIndex = uint3(CurrGridXZIndex.x, CurrGridYIndex, CurrGridXZIndex.y);
    float3 CurrCenterCellPosition = CurrCenterCell3DIndex * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
    
    uint CurrTallCellLinerIndex = computeMorton2D((uint2) (RelativeXZ / CellLength));
    uint PrevTallCellLinerIndex = ThreadIdx == 0 ? 0 : WaveReadLaneAt(CurrTallCellLinerIndex, CurrLaneIndex - 1);
    uint NextTallCellLinerIndex = ThreadIdx == CurrLaneCount - 1 ? 0 : WaveReadLaneAt(CurrTallCellLinerIndex, CurrLaneIndex + 1);
    
    //r: Lane31~Lane0, g: Lane63~Lane32...
    uint4 BallotResult1 = WaveActiveBallot(ThreadIdx == 0 || PrevTallCellLinerIndex != CurrTallCellLinerIndex);
    uint4 BallotResult2 = WaveActiveBallot(ThreadIdx == CurrLaneCount - 1 || NextTallCellLinerIndex != CurrTallCellLinerIndex);
    uint IntraOffset = doCLZHighToLow(MaskUnusedBit(BallotResult2, CurrLaneCount), CurrLaneIndex);
    uint InvIntraOffset = doCLZLowToHigh(MaskUnusedBit(BallotResult1, CurrLaneCount), CurrLaneIndex);
    uint RegionLength = InvIntraOffset + IntraOffset + 1;
    
    //warp level reduce
    int c = GroupIdx.y;
    int2 AdjTallCell2DIndex = CurrGridXZIndex + OffsetVector2D[c];
    if (any(AdjTallCell2DIndex < 0) || any(AdjTallCell2DIndex >= XZResolution))
        return;
        
    float AdjTerrianHeight = TerrianHeight_R[AdjTallCell2DIndex];
    float X = RelativeY - AdjTerrianHeight;
    if (X < 0)
        return;
        
    float XX = X * X;
        
    float2 AdjPointXZ = CurrCenterCellPosition.xz + OffsetVector2D[c] * CellLength;
    float3 AdjPoint = float3(AdjPointXZ.x, RelativePosition.y, AdjPointXZ.y);
        
    float Weight = CubicKernel(length(RelativePosition - AdjPoint) / CellLength);
    float3 Y = Weight * CurrVelocity;
    float3 XY = X * Y;
        
    uint ParticleIncFactor = 1;
        
    for (int k = 0; k < ceil(log2(RegionLength)); k++)
    {
        uint IntraEnd = floor((float) RegionLength / pow(2.0f, k + 1));
        uint Offset = ceil((float) RegionLength / pow(2.0f, k + 1));
            
        uint AnotherParticleIncFactor = WaveReadLaneAt(ParticleIncFactor, CurrLaneIndex + Offset);
        float AnotherX = WaveReadLaneAt(X, CurrLaneIndex + Offset);
        float3 AnotherY = WaveReadLaneAt(Y, CurrLaneIndex + Offset);
        float AnotherXX = WaveReadLaneAt(XX, CurrLaneIndex + Offset);
        float3 AnotherXY = WaveReadLaneAt(XY, CurrLaneIndex + Offset);
        if (IntraOffset < IntraEnd)
        {
            ParticleIncFactor += AnotherParticleIncFactor;
            X += AnotherX;
            Y += AnotherY;
            XX += AnotherXX;
            XY += AnotherXY;
        }
    }
        
    if (IntraOffset == 0)
    {
        InterlockedAdd(ParticleCount_RW[AdjTallCell2DIndex], ParticleIncFactor);
            
        int XIntZIP = floor(X);
        int XFloatZIP = (X - XIntZIP) * ZIP;
        InterlockedAdd(XSum_RW[uint3(AdjTallCell2DIndex, 0)], XIntZIP);
        InterlockedAdd(XSum_RW[uint3(AdjTallCell2DIndex, 1)], XFloatZIP);
            
        int XXIntZIP = floor(XX);
        int XXFloatZIP = (XX - XXIntZIP) * ZIP;
        InterlockedAdd(XXSum_RW[uint3(AdjTallCell2DIndex, 0)], XXIntZIP);
        InterlockedAdd(XXSum_RW[uint3(AdjTallCell2DIndex, 1)], XXFloatZIP);
            
        int3 YIntZIP = int3(floor(Y.x), floor(Y.y), floor(Y.z));
        int3 YFloatZIP = (Y - YIntZIP) * ZIP;
        InterlockedAdd(YSum_RW[uint3(AdjTallCell2DIndex, 0)], YIntZIP.x);
        InterlockedAdd(YSum_RW[uint3(AdjTallCell2DIndex, 1)], YIntZIP.y);
        InterlockedAdd(YSum_RW[uint3(AdjTallCell2DIndex, 2)], YIntZIP.z);
        InterlockedAdd(YSum_RW[uint3(AdjTallCell2DIndex, 3)], YFloatZIP.x);
        InterlockedAdd(YSum_RW[uint3(AdjTallCell2DIndex, 4)], YFloatZIP.y);
        InterlockedAdd(YSum_RW[uint3(AdjTallCell2DIndex, 5)], YFloatZIP.z);
            
        int3 XYIntZIP = int3(floor(XY.x), floor(XY.y), floor(XY.z));
        int3 XYFloatZIP = (XY - XYIntZIP) * ZIP;
        InterlockedAdd(XYSum_RW[uint3(AdjTallCell2DIndex, 0)], XYIntZIP.x);
        InterlockedAdd(XYSum_RW[uint3(AdjTallCell2DIndex, 1)], XYIntZIP.y);
        InterlockedAdd(XYSum_RW[uint3(AdjTallCell2DIndex, 2)], XYIntZIP.z);
        InterlockedAdd(XYSum_RW[uint3(AdjTallCell2DIndex, 3)], XYFloatZIP.x);
        InterlockedAdd(XYSum_RW[uint3(AdjTallCell2DIndex, 4)], XYFloatZIP.y);
        InterlockedAdd(XYSum_RW[uint3(AdjTallCell2DIndex, 5)], XYFloatZIP.z);
    }
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void scatterOnlyTallCellParticleToGrid_Pass2(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float XSum = XSum_R[uint3(DispatchThreadID.xy, 0)] + (XSum_R[uint3(DispatchThreadID.xy, 1)] / (float) ZIP);
    float XXSum = XXSum_R[uint3(DispatchThreadID.xy, 0)] + (XXSum_R[uint3(DispatchThreadID.xy, 1)] / (float) ZIP);
    float3 YSum = float3(
        YSum_R[uint3(DispatchThreadID.xy, 0)] + (YSum_R[uint3(DispatchThreadID.xy, 3)] / (float) ZIP),
        YSum_R[uint3(DispatchThreadID.xy, 1)] + (YSum_R[uint3(DispatchThreadID.xy, 4)] / (float) ZIP),
        YSum_R[uint3(DispatchThreadID.xy, 2)] + (YSum_R[uint3(DispatchThreadID.xy, 5)] / (float) ZIP)
    );
    float3 XYSum = float3(
        XYSum_R[uint3(DispatchThreadID.xy, 0)] + XYSum_R[uint3(DispatchThreadID.xy, 3)] / (float) ZIP,
        XYSum_R[uint3(DispatchThreadID.xy, 1)] + XYSum_R[uint3(DispatchThreadID.xy, 4)] / (float) ZIP,
        XYSum_R[uint3(DispatchThreadID.xy, 2)] + XYSum_R[uint3(DispatchThreadID.xy, 5)] / (float) ZIP
    );
    
    uint M = ParticleCount_R[DispatchThreadID.xy];
    
    float CenterTerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float CenterTallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    
    float3 Sigma0 = (XXSum * YSum - XSum * XYSum) / (M * XXSum - pow(XSum, 2));
    float3 Sigma1 = (M * XYSum - XSum * YSum) / (M * XXSum - pow(XSum, 2));
    float3 TopValue = Sigma0 + Sigma1 * (CenterTallCellHeight - 0.5f * CellLength);
    float3 BottomValue = Sigma0 + Sigma1 * 0.5f * CellLength;
    
    TopCellVelocity_RW[DispatchThreadID.xy] = TopValue;
    BottomCellVelocity_RW[DispatchThreadID.xy] = BottomValue;
}

Texture3D<int> RegularCellWeight_R;
Texture3D<int> RegularCellWeightedVelocity_R_R;
Texture3D<int> RegularCellWeightedVelocity_G_R;
Texture3D<int> RegularCellWeightedVelocity_B_R;
RWTexture3D<int> RegularCellWeight_RW;
RWTexture3D<int> RegularCellWeightedVelocity_R_RW;
RWTexture3D<int> RegularCellWeightedVelocity_G_RW;
RWTexture3D<int> RegularCellWeightedVelocity_B_RW;
[numthreads(THREAD_COUNT_1D, 1, 1)]
void scatterRegularParticleToGrid_Pass1(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint CurrLaneIndex = WaveGetLaneIndex();
    uint CurrLaneCount = WaveGetLaneCount();
    
    uint Count = ParticleIndrectArgment_R[DifferParticleCountArgumentOffset + OnlyRegularCellParticleType];
    uint Offset = OnlyRegularCellParticleType == 0 ? 0 : ParticleIndrectArgment_R[DifferParticleSplitPointArgumentOffset + OnlyRegularCellParticleType - 1];
    uint i = Offset + ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i - Offset >= Count)
        return;

    float3 CurrPosition = ParticlePosition_R[i];
    float3 CurrVelocity = ParticleVelocity_R[i];
    
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    float RelativeY = CurrPosition.y - Min.y;
    
    float3 RelativePoition = float3(RelativeXZ.x, RelativeY, RelativeXZ.y);
    float3 CenterGridPosition = floor(RelativePoition / CellLength) * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
    
    //unzip cell morton code
    uint2 CurrGridXZIndex = RelativePoition.xz / CellLength;
    float CenterTerrianHeight = TerrianHeight_R[CurrGridXZIndex];
    float CenterTallCellHeight = TallCellHeight_R[CurrGridXZIndex];
    uint CurrGridYIndex = (RelativePoition.y - CenterTerrianHeight - CenterTallCellHeight) / CellLength;
    uint3 Cell3DIndex = uint3(CurrGridXZIndex.x, CurrGridYIndex, CurrGridXZIndex.y);
    uint CurrRegularCellLinerIndex = computeMorton3D(Cell3DIndex);
    uint PrevRegularCellLinerIndex = ThreadIdx == 0 ? 0 : WaveReadLaneAt(CurrRegularCellLinerIndex, CurrLaneIndex - 1);
    uint NextRegularCellLinerIndex = ThreadIdx == CurrLaneCount - 1 ? 0 : WaveReadLaneAt(CurrRegularCellLinerIndex, CurrLaneIndex + 1);
    
    //r: Lane31~Lane0, g: Lane63~Lane32...
    uint4 BallotResult1 = WaveActiveBallot(ThreadIdx == 0 || PrevRegularCellLinerIndex != CurrRegularCellLinerIndex);
    uint4 BallotResult2 = WaveActiveBallot(ThreadIdx == CurrLaneCount - 1 || NextRegularCellLinerIndex != CurrRegularCellLinerIndex);
    uint IntraOffset = doCLZHighToLow(MaskUnusedBit(BallotResult2, CurrLaneCount), CurrLaneIndex);
    uint InvIntraOffset = doCLZLowToHigh(MaskUnusedBit(BallotResult1, CurrLaneCount), CurrLaneIndex);
    uint RegionLength = InvIntraOffset + IntraOffset + 1;
    
    //warp level reduce
    for (int c = 0; c < 27; c++)
    {
        float3 AdjContributePoint = CenterGridPosition + OffsetVector3D[c] * CellLength;
        int2 AdjContributePointXZIndex = AdjContributePoint.xz / CellLength;
        
        CenterTerrianHeight = TerrianHeight_R[AdjContributePointXZIndex];
        CenterTallCellHeight = TallCellHeight_R[AdjContributePointXZIndex];
        
        int AdjContributePointYIndex = (AdjContributePoint.y - CenterTerrianHeight - CenterTallCellHeight) / CellLength;
        int3 AdjContributePoint3DIndex = int3(AdjContributePointXZIndex.x, AdjContributePointYIndex, AdjContributePointXZIndex.y);
        if (any(AdjContributePoint3DIndex < 0) || any(AdjContributePointXZIndex >= XZResolution) || AdjContributePointYIndex > ConstantCellNum)
            continue;
        
        float Weight = CubicKernel(length(RelativePoition - AdjContributePoint) / CellLength);
        float3 WeightVelocity = Weight * CurrVelocity;
        
        for (int k = 0; k < ceil(log2(RegionLength)); k++)
        {
            uint IntraEnd = floor((float) RegionLength / pow(2.0f, k + 1));
            uint ReductionFactor = ceil((float) RegionLength / pow(2.0f, k + 1));
            
            float AnotherWeight = WaveReadLaneAt(Weight, CurrLaneIndex + ReductionFactor);
            float AnotherWeightVelocity = WaveReadLaneAt(WeightVelocity, CurrLaneIndex + ReductionFactor);
            if (IntraOffset < IntraEnd)
            {
                Weight += AnotherWeight;
                WeightVelocity += AnotherWeightVelocity;
            }
        }
        
        if (IntraOffset == 0)
        {
            InterlockedAdd(RegularCellWeight_RW[AdjContributePoint3DIndex], Weight * ZIP);
            InterlockedAdd(RegularCellWeightedVelocity_R_RW[AdjContributePoint3DIndex], WeightVelocity.x * ZIP);
            InterlockedAdd(RegularCellWeightedVelocity_G_RW[AdjContributePoint3DIndex], WeightVelocity.y * ZIP);
            InterlockedAdd(RegularCellWeightedVelocity_B_RW[AdjContributePoint3DIndex], WeightVelocity.z * ZIP);
        }
    }
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void scatterRegularParticleToGrid_Pass2(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y > ConstantCellNum)
        return;
    
    float Weight = RegularCellWeight_R[DispatchThreadID] / (float) ZIP;
    float3 WeightedVelocity = float3(
        RegularCellWeightedVelocity_R_R[DispatchThreadID] / (float) ZIP,
        RegularCellWeightedVelocity_G_R[DispatchThreadID] / (float) ZIP,
        RegularCellWeightedVelocity_B_R[DispatchThreadID] / (float) ZIP
    );
    
    float3 FinalValue = float3(0, 0, 0);
    if (Weight != 0)
        FinalValue = WeightedVelocity / Weight;
    RegularCellVelocity_RW[DispatchThreadID] = FinalValue;
}