#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel markParticleByCellType
#pragma kernel gatherGridToParticle
#pragma kernel scatterOnlyTallCellParticleToGrid

uint ParticleCountOffset;

StructuredBuffer<int> ParticleIndrectArgment_R;

StructuredBuffer<float3> ParticlePosition_R;
StructuredBuffer<float3> ParticleVelocity_R;
StructuredBuffer<uint> ParticleFilter_R;
RWStructuredBuffer<float3> ParticleVelocity_RW;
RWStructuredBuffer<uint> ParticleFilter_RW;
Texture2D<float> TerrianHeight_R;
Texture2D<float> TallCellHeight_R;

Texture3D<float3> RegularCellVelocity_R;
Texture2D<float3> TopCellVelocity_R;
Texture2D<float3> BottomCellVelocity_R;
RWTexture3D<float3> RegularCellVelocity_RW;
RWTexture2D<float3> TopCellVelocity_RW;
RWTexture2D<float3> BottomCellVelocity_RW;

const int2 OffsetVector2D[3 * 3] =
{
    { -1, 0 },
    { 1, 0 },
    { 0, -1 },
    { 0, 1 },
    { 1, 1 },
    { -1, -1 },
    { -1, 1 },
    { 1, -1 },
    { 0, 0 }
};

const int3 OffsetVector3D[3 * 3 * 3] =
{
    { -1, 0, 0},
    { 1, 0, 0 },
    { 0, -1, 0 },
    { 0, 1, 0 },
    { 1, 1, 0 },
    { -1, -1, 0 },
    { -1, 1, 0 },
    { 1, -1, 0 },
    { 0, 0, 0 },
    
    { -1, 0, 1 },
    { 1, 0, 1 },
    { 0, -1, 1 },
    { 0, 1, 1 },
    { 1, 1, 1 },
    { -1, -1, 1 },
    { -1, 1, 1 },
    { 1, -1, 1 },
    { 0, 0, 1 },
    
    { -1, 0, -1 },
    { 1, 0, -1 },
    { 0, -1, -1 },
    { 0, 1, -1 },
    { 1, 1, -1 },
    { -1, -1, -1 },
    { -1, 1, -1 },
    { 1, -1, -1 },
    { 0, 0, -1 }
};

[numthreads(THREAD_COUNT_1D, 1, 1)]
void markParticleByCellType(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    
    float CenterTerrianHeight = TerrianHeight_R[CurrGridXZIndex];
    float CenterTallCellHeight = TallCellHeight_R[CurrGridXZIndex];
    
    bool IsInTerrianCell = false;
    bool IsInTallCell = false;
    bool IsAnyTallCellHigher = false;
    bool IsAnyTallCellLower = false;
    
    if (RelativeHeight < CenterTerrianHeight)
        IsInTerrianCell = true;
    
    if (RelativeHeight < CenterTerrianHeight + CenterTallCellHeight && RelativeHeight >= CenterTerrianHeight)
        IsInTallCell = true;
    
    for (int c = 0; c < 3 * 3 - 1; c++)
    {
        float SurroundTerrianHeight = TerrianHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        float SurroundTallCellHeight = TallCellHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        
        if (RelativeHeight < SurroundTallCellHeight + SurroundTerrianHeight + CellLength)
        {
            IsAnyTallCellHigher = true;
        }
        
        if (RelativeHeight > SurroundTallCellHeight + SurroundTerrianHeight - CellLength)
        {
            IsAnyTallCellLower = true;
        }
    }
    
    if (!IsInTallCell && !IsInTerrianCell)
    {
        if (IsAnyTallCellHigher)
            ParticleFilter_RW[i] = 1;
        else
            ParticleFilter_RW[i] = 0;
    }
    else if (IsInTallCell)
    {
        if (!IsAnyTallCellLower)
            ParticleFilter_RW[i] = 3;
        else
            ParticleFilter_RW[i] = 2;
    }
    else
    {
        ParticleFilter_RW[i] = 4;
    }
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void gatherGridToParticle(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    uint CurrGridYIndex = RelativeHeight / CellLength;
    
    float CenterTerrianHeight = TerrianHeight_R[CurrGridXZIndex];
    float CenterTallCellHeight = TallCellHeight_R[CurrGridXZIndex];
    
    float3 CurrCenterCellPosition = float3(CurrGridXZIndex.x, CurrGridYIndex, CurrGridXZIndex.y) * CellLength;
    float WeightSum = 0.0f;
    float3 WeightValue = float3(0, 0, 0);
    for (int c = 0; c < 3 * 3 * 3; c++)
    {
        float3 AdjPoint = CurrCenterCellPosition + OffsetVector3D[c] * CellLength;
        float Weight = CubicKernel(length(AdjPoint - CurrCenterCellPosition) / CellLength);
        
        float3 Value = float3(0, 0, 0);
        if (AdjPoint.y >= CenterTerrianHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight)
        {
            float3 TopValue = TopCellVelocity_R[CurrGridXZIndex];
            float3 BottomValue = BottomCellVelocity_R[CurrGridXZIndex];
            float RelativeHeight = (AdjPoint.y - CenterTerrianHeight) / CenterTallCellHeight;
            Value = RelativeHeight * TopValue + (1.0f - RelativeHeight) * BottomValue;
        }
        else if (AdjPoint.y >= CenterTerrianHeight + CenterTallCellHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight + ConstantCellNum * CellLength)
        {
            uint YIndex = (AdjPoint.y - CenterTerrianHeight - CenterTallCellHeight) / CellLength;
            Value = RegularCellVelocity_R[uint3(CurrGridXZIndex.x, YIndex, CurrGridXZIndex.y)];
        }
        else
        {
            Value = float3(0, 0, 0);
        }
        WeightValue += Value * Weight;
        WeightSum += Weight;
    }
    ParticleVelocity_RW[i] = WeightValue / WeightSum;
}

//RWStructuredBuffer<float3> SortedParticlePosition_RW;
//RWStructuredBuffer<float3> SortedParticleVelocity_RW;
//RWStructuredBuffer<uint> SortedParticleFilter_RW;

//StructuredBuffer<uint> ParticleInnerSortIndex_R;
//RWStructuredBuffer<uint> ParticleInnerSortIndex_RW;

//StructuredBuffer<uint> ParticleCellIndex_R;
//RWStructuredBuffer<uint> ParticleCellIndex_RW;

//StructuredBuffer<uint> HashGridCellParticleOffset_R;
//RWStructuredBuffer<uint> HashGridCellParticleCount_RW;
//[numthreads(THREAD_COUNT_1D, 1, 1)]
//void insertParticleInto2DHashGrid(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
//{
//    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
//    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
//        return;
    
//    float3 Postion = ParticlePosition_R[i];
//    uint2 Cell3DIndex = uint2((Postion.xz - Min.xz) / CellLength);
//    uint CellLinerIndex = computeMorton2D(Cell3DIndex);
    
//    ParticleCellIndex_RW[i] = CellLinerIndex;
//    uint OriginValue;
//    InterlockedAdd(HashGridCellParticleCount_RW[CellLinerIndex], 1, OriginValue);
//    ParticleInnerSortIndex_RW[i] = OriginValue;
//}

//[numthreads(THREAD_COUNT_1D, 1, 1)]
//void countingSortFull(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
//{
//    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
//    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
//        return;
    
//    uint CellLinerIndex = ParticleCellIndex_R[i];
//    uint Offset = HashGridCellParticleOffset_R[CellLinerIndex];
//    uint Index = ParticleInnerSortIndex_R[i];
//    uint SortedIndex = Offset + Index;
//    SortedParticlePosition_RW[SortedIndex] = ParticlePosition_R[i];
//    SortedParticleVelocity_RW[SortedIndex] = ParticleVelocity_R[i];
//    SortedParticleFilter_RW[SortedIndex] = ParticleFilter_R[i];
//}

//TODO: we can use sort and warp-level perfixsum to discard many interlocked operation
[numthreads(THREAD_COUNT_1D, 1, 1)]
void scatterOnlyTallCellParticleToGrid(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    
    float CenterTerrianHeight = TerrianHeight_R[CurrGridXZIndex];
    float CenterTallCellHeight = TallCellHeight_R[CurrGridXZIndex];
    
}