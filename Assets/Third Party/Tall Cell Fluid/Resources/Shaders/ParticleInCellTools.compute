#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel markParticleByCellType
#pragma kernel gatherGridToParticle
#pragma kernel scatterOnlyTallCellParticleToGrid_Pass1
#pragma kernel scatterOnlyTallCellParticleToGrid_Pass2
#pragma kernel gatherOnlyTallCellParticleToGrid
#pragma use_dxc

uint ParticleCountOffset;
uint ParticleCountArgumentIndex;
uint ParticleOffsetArgumentIndex;
uint OnlyTallCellParticleType;

StructuredBuffer<int> ParticleIndrectArgment_R;

StructuredBuffer<float3> ParticlePosition_R;
StructuredBuffer<float3> ParticleVelocity_R;
StructuredBuffer<uint> ParticleFilter_R;
RWStructuredBuffer<float3> ParticleVelocity_RW;
RWStructuredBuffer<uint> ParticleFilter_RW;
StructuredBuffer<uint> HashGridCellParticleCount_R;
StructuredBuffer<uint> HashGridCellParticleOffset_R;
Texture2D<float> TerrianHeight_R;
Texture2D<float> TallCellHeight_R;

Texture3D<float3> RegularCellVelocity_R;
Texture2D<float3> TopCellVelocity_R;
Texture2D<float3> BottomCellVelocity_R;
RWTexture3D<float3> RegularCellVelocity_RW;
RWTexture2D<float3> TopCellVelocity_RW;
RWTexture2D<float3> BottomCellVelocity_RW;

int2 OffsetVector2D[3 * 3] =
{
    { -1, 0 },
    { 1, 0 },
    { 0, -1 },
    { 0, 1 },
    { 1, 1 },
    { -1, -1 },
    { -1, 1 },
    { 1, -1 },
    { 0, 0 }
};

int3 OffsetVector3D[3 * 3 * 3] =
{
    { -1, 0, 0},
    { 1, 0, 0 },
    { 0, -1, 0 },
    { 0, 1, 0 },
    { 1, 1, 0 },
    { -1, -1, 0 },
    { -1, 1, 0 },
    { 1, -1, 0 },
    { 0, 0, 0 },
    
    { -1, 0, 1 },
    { 1, 0, 1 },
    { 0, -1, 1 },
    { 0, 1, 1 },
    { 1, 1, 1 },
    { -1, -1, 1 },
    { -1, 1, 1 },
    { 1, -1, 1 },
    { 0, 0, 1 },
    
    { -1, 0, -1 },
    { 1, 0, -1 },
    { 0, -1, -1 },
    { 0, 1, -1 },
    { 1, 1, -1 },
    { -1, -1, -1 },
    { -1, 1, -1 },
    { 1, -1, -1 },
    { 0, 0, -1 }
};

[numthreads(THREAD_COUNT_1D, 1, 1)]
void markParticleByCellType(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    
    float CenterTerrianHeight = TerrianHeight_R[CurrGridXZIndex];
    float CenterTallCellHeight = TallCellHeight_R[CurrGridXZIndex];
    
    bool IsInTerrianCell = false;
    bool IsInTallCell = false;
    bool IsAnyTallCellHigher = false;
    bool IsAnyTallCellLower = false;
    
    if (RelativeHeight < CenterTerrianHeight)
        IsInTerrianCell = true;
    
    if (RelativeHeight < CenterTerrianHeight + CenterTallCellHeight && RelativeHeight >= CenterTerrianHeight)
        IsInTallCell = true;
    
    for (int c = 0; c < 3 * 3 - 1; c++)
    {
        float SurroundTerrianHeight = TerrianHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        float SurroundTallCellHeight = TallCellHeight_R[CurrGridXZIndex + OffsetVector2D[c]];
        
        if (RelativeHeight < SurroundTallCellHeight + SurroundTerrianHeight + CellLength)
        {
            IsAnyTallCellHigher = true;
        }
        
        if (RelativeHeight > SurroundTallCellHeight + SurroundTerrianHeight - CellLength)
        {
            IsAnyTallCellLower = true;
        }
    }
    
    if (!IsInTallCell && !IsInTerrianCell)
    {
        if (IsAnyTallCellHigher)
            ParticleFilter_RW[i] = 1;
        else
            ParticleFilter_RW[i] = 0;
    }
    else if (IsInTallCell)
    {
        if (!IsAnyTallCellLower)
            ParticleFilter_RW[i] = 3;
        else
            ParticleFilter_RW[i] = 1;
    }
    else
    {
        ParticleFilter_RW[i] = 4;
    }
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void gatherGridToParticle(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= ParticleIndrectArgment_R[ParticleCountOffset])
        return;
    
    float3 CurrPosition = ParticlePosition_R[i];
    float RelativeHeight = CurrPosition.y - Min.y;
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    uint CurrGridYIndex = RelativeHeight / CellLength;
    
    float3 CurrCenterCellPosition = float3(CurrGridXZIndex.x + 0.5f, CurrGridYIndex + 0.5f, CurrGridXZIndex.y + 0.5f) * CellLength;
    float WeightSum = 0.0f;
    float3 WeightValue = float3(0, 0, 0);
    for (int c = 0; c < 3 * 3 * 3; c++)
    {
        uint2 AdjXZ = CurrGridXZIndex + OffsetVector3D[c].xz;
        float CenterTerrianHeight = TerrianHeight_R[AdjXZ];
        float CenterTallCellHeight = TallCellHeight_R[AdjXZ];
        
        float3 AdjPoint = CurrCenterCellPosition + OffsetVector3D[c] * CellLength;
        float Weight = CubicKernel(length(AdjPoint - CurrCenterCellPosition) / CellLength);
        
        float3 Value = float3(0, 0, 0);
        if (AdjPoint.y >= CenterTerrianHeight + CenterTallCellHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight + ConstantCellNum * CellLength)
        {
            uint YIndex = (AdjPoint.y - 0.5f * CellLength - CenterTerrianHeight - CenterTallCellHeight) / CellLength;
            Value = RegularCellVelocity_R[uint3(AdjXZ.x, YIndex, AdjXZ.y)];
        }
        else
        {
            Value = float3(0, 0, 0);
        }
        WeightValue += Value * Weight;
        WeightSum += Weight;
    }
    
    for (c = 0; c < 3 * 3; c++)
    {
        uint2 AdjXZ = CurrGridXZIndex + OffsetVector2D[c];
        float CenterTerrianHeight = TerrianHeight_R[AdjXZ];
        float CenterTallCellHeight = TallCellHeight_R[AdjXZ];
        
        float3 AdjPoint = CurrPosition + float3(OffsetVector2D[c].x, 0, OffsetVector2D[c].y) * CellLength;
        float Weight = CubicKernel(length(AdjPoint - CurrCenterCellPosition) / CellLength);
        
        float3 Value = float3(0, 0, 0);
        if (AdjPoint.y >= CenterTerrianHeight && AdjPoint.y < CenterTerrianHeight + CenterTallCellHeight)
        {
            float3 TopValue = TopCellVelocity_R[AdjXZ];
            float3 BottomValue = BottomCellVelocity_R[AdjXZ];
            float RelativeHeight = (AdjPoint.y - (CenterTerrianHeight + 0.5f * CellLength)) / (CenterTallCellHeight - CellLength);
            Value = RelativeHeight * TopValue + (1.0f - RelativeHeight) * BottomValue;
        }
        WeightValue += Value * Weight;
        WeightSum += Weight;
    }
    
    ParticleVelocity_RW[i] = WeightValue / WeightSum;
}


uint doCLZLowToHigh(uint4 vInput, uint vTargetBit)
{
    uint Result = 0;
    
    uint Index = vTargetBit / 32;
    uint Offset = vTargetBit % 32;
    
    for (int c = Index; c < 4; c++)
    {
        if (c == Index)
            vInput[c] &= ~(0xFFFFFFFF >> (32 - Offset - 1));
        
        uint FirstIndex = firstbitlow(vInput[c]);
        if (FirstIndex != 0xFFFFFFFF)
        {
            Result += FirstIndex - Offset - 1;
            break;
        }
        else
        {
            Result += 32 - Offset - 1;
            Offset = -1;
        }
    }
    return Result;
}

uint doCLZHighToLow(uint4 vInput, uint vTargetBit)
{
    uint Result = 0;
    
    uint Index = vTargetBit / 32;
    uint Offset = vTargetBit % 32;
    
    for (int c = Index; c >= 0; c--)
    {
        if (c == Index)
            vInput[c] &= ~((0xFFFFFFFF >> Offset) << Offset);
        
        uint FirstIndex = firstbithigh(vInput[c]);
        if (FirstIndex != 0xFFFFFFFF)
        {
            Result += Offset - FirstIndex - 1;
            break;
        }
        else
        {
            Result += Offset;
            Offset = 32;
        }
    }
    return Result;
}

RWStructuredBuffer<uint3> DEBUG;
groupshared uint LocalParticleCount[THREAD_COUNT_1D / MIN_WARP_COUNT][9];
groupshared float LocalXSum[THREAD_COUNT_1D / MIN_WARP_COUNT][9];
groupshared float LocalXXSum[THREAD_COUNT_1D / MIN_WARP_COUNT][9];
groupshared float3 LocalYSum[THREAD_COUNT_1D / MIN_WARP_COUNT][9];
groupshared float3 LocalXYSum[THREAD_COUNT_1D / MIN_WARP_COUNT][9];

#define ZIP 10000000
Texture2D<uint> ParticleCount_R;
RWTexture2D<uint> ParticleCount_RW;
Texture2D<int> XSum_R;
RWTexture2D<int> XSum_RW;
Texture2D<int> XXSum_R;
RWTexture2D<int> XXSum_RW;
Texture2D<int> YSum_R_R;
RWTexture2D<int> YSum_R_RW;
Texture2D<int> YSum_G_R;
RWTexture2D<int> YSum_G_RW;
Texture2D<int> YSum_B_R;
RWTexture2D<int> YSum_B_RW;
Texture2D<int> XYSum_R_R;
RWTexture2D<int> XYSum_R_RW;
Texture2D<int> XYSum_G_R;
RWTexture2D<int> XYSum_G_RW;
Texture2D<int> XYSum_B_R;
RWTexture2D<int> XYSum_B_RW;

RWTexture2D<float3> Top_RW;
RWTexture2D<float3> Bottom_RW;

[numthreads(THREAD_COUNT_1D, 1, 1)]
void scatterOnlyTallCellParticleToGrid_Pass1(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    if (ThreadIdx < THREAD_COUNT_1D / MIN_WARP_COUNT)
    {
        for (int k = 0; k < 9; k++)
        {
            LocalXSum[ThreadIdx][k] = 0;
            LocalXXSum[ThreadIdx][k] = 0;
            LocalYSum[ThreadIdx][k] = 0;
            LocalXYSum[ThreadIdx][k] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    
    uint CurrLaneIndex = WaveGetLaneIndex();
    uint CurrLaneCount = WaveGetLaneCount();
    uint CurrWarpIndex = ThreadIdx / CurrLaneCount;
    
    float3 CurrPosition = float3(0, 0, 0);
    float3 CurrVelocity = float3(0, 0, 0);
    
    uint Count = ParticleIndrectArgment_R[ParticleCountArgumentIndex + OnlyTallCellParticleType];
    uint Offset = OnlyTallCellParticleType == 0 ? 0 : ParticleIndrectArgment_R[ParticleOffsetArgumentIndex + OnlyTallCellParticleType - 1];
    uint i = Offset + ThreadIdx + GroupIdx * THREAD_COUNT_1D;
    if (i >= Count)
    {
        CurrPosition = ParticlePosition_R[i];
        CurrVelocity = ParticleVelocity_R[i];
    }
    
    float2 RelativeXZ = CurrPosition.xz - Min.xz;
    uint2 CurrGridXZIndex = RelativeXZ / CellLength;
    uint CurrTallCellLinerIndex = computeMorton2D(RelativeXZ / CellLength);
    uint PrevTallCellLinerIndex = ThreadIdx == 0 ? 0 : WaveReadLaneAt(CurrTallCellLinerIndex, CurrLaneIndex - 1);
    uint NextTallCellLinerIndex = ThreadIdx == CurrLaneCount - 1 ? 0 : WaveReadLaneAt(CurrTallCellLinerIndex, CurrLaneIndex + 1);
    
    //r: Lane31~Lane0, g: Lane63~Lane32...
    uint4 BallotResult1 = WaveActiveBallot(!(ThreadIdx == 0 || PrevTallCellLinerIndex != CurrTallCellLinerIndex));
    uint4 BallotResult2 = WaveActiveBallot(!(ThreadIdx == CurrLaneCount - 1 || NextTallCellLinerIndex != CurrTallCellLinerIndex));
    uint RegionLength = doCLZLowToHigh(BallotResult1, CurrLaneIndex) + doCLZHighToLow(BallotResult2, CurrLaneIndex);
    
    //warp level reduce
    for (int c = 0; c < 9; c++)
    {
        int2 CurrOffset = OffsetVector2D[c];
        uint2 AdjTallCell2DIndex = CurrGridXZIndex + CurrOffset;
        
        if (any(AdjTallCell2DIndex < 0) || any(AdjTallCell2DIndex >= XZResolution))
            continue;
        
        float AdjTerrianHeight = TerrianHeight_R[AdjTallCell2DIndex];
        float X = CurrPosition.y - Min.y - AdjTerrianHeight;
        if(X < 0)
            continue;
        float XX = X * X;
        
        float Weight = CubicKernel(length(RelativeXZ - ((float2) AdjTallCell2DIndex * CellLength + float2(0.5f, 0.5f) * CellLength)));
        float3 Y = Weight * CurrVelocity;
        float3 XY = X * Y;
        
        uint ParticleCount = 1;
        
        uint Offset = RegionLength;
        for (int k = 0; k < ceil(log2(RegionLength)); k++)
        {
            Offset = ceil(Offset / 2.0f);
            if (CurrLaneIndex + Offset < RegionLength)
            {
                X += WaveReadLaneAt(X, CurrLaneIndex + RegionLength);
                Y += WaveReadLaneAt(Y, CurrLaneIndex + RegionLength);
                XY += WaveReadLaneAt(XY, CurrLaneIndex + RegionLength);
                XY += WaveReadLaneAt(XY, CurrLaneIndex + RegionLength);
            }
        }
        
        if(CurrLaneIndex == 0)
        {
            LocalXSum[CurrWarpIndex][c] = X;
            LocalXXSum[CurrWarpIndex][c] = XX;
            LocalYSum[CurrWarpIndex][c] = Y;
            LocalXYSum[CurrWarpIndex][c] = XY;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    
    //block level reduce
    uint ReductionRegionLength = THREAD_COUNT_1D / MIN_WARP_COUNT;
    if (ThreadIdx < ReductionRegionLength)
    {
        for (c = 0; c < 9; c++)
        {
            uint2 AdjTallCell2DIndex = CurrGridXZIndex + OffsetVector2D[c];
        
            if (any(AdjTallCell2DIndex < 0) || any(AdjTallCell2DIndex >= XZResolution))
                continue;
            
            float XSum = LocalXSum[ThreadIdx][c];
            float XXSum = LocalXXSum[ThreadIdx][c];
            float3 YSum = LocalYSum[ThreadIdx][c];
            float3 XYSum = LocalXYSum[ThreadIdx][c];
            uint Offset = ReductionRegionLength;
            for (int k = 0; k < ceil(log2(ReductionRegionLength)); k++)
            {
                Offset = ceil(Offset / 2.0f);
                if (ThreadIdx + Offset < ReductionRegionLength)
                {
                    XSum += LocalXSum[ThreadIdx + Offset][c];
                    XXSum += LocalXXSum[ThreadIdx + Offset][c];
                    YSum += LocalYSum[ThreadIdx + Offset][c];
                    XYSum += LocalXYSum[ThreadIdx + Offset][c];
                }
            }
            
            //interlocked add to global memeory
            if(ThreadIdx == 0)
            {
                InterlockedAdd(XSum_RW[AdjTallCell2DIndex], XSum * ZIP);
                InterlockedAdd(XXSum_RW[AdjTallCell2DIndex], XXSum * ZIP);
                InterlockedAdd(YSum_R_RW[AdjTallCell2DIndex], YSum.x * ZIP);
                InterlockedAdd(YSum_G_RW[AdjTallCell2DIndex], YSum.y * ZIP);
                InterlockedAdd(YSum_B_RW[AdjTallCell2DIndex], YSum.z * ZIP);
                InterlockedAdd(XYSum_R_RW[AdjTallCell2DIndex], XYSum.x * ZIP);
                InterlockedAdd(XYSum_G_RW[AdjTallCell2DIndex], XYSum.y * ZIP);
                InterlockedAdd(XYSum_B_RW[AdjTallCell2DIndex], XYSum.z * ZIP);
            }
        }
    }
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void scatterOnlyTallCellParticleToGrid_Pass2(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float XSum = XSum_R[DispatchThreadID.xy] / (float) ZIP;
    float XXSum = XXSum_R[DispatchThreadID.xy] / (float) ZIP;
    float3 YSum = float3(
        YSum_R_R[DispatchThreadID.xy] / (float) ZIP, 
        YSum_G_R[DispatchThreadID.xy] / (float) ZIP,
        YSum_B_R[DispatchThreadID.xy] / (float) ZIP
    );
    float3 XYSum = float3(
        XYSum_R_R[DispatchThreadID.xy] / (float) ZIP,
        XYSum_G_R[DispatchThreadID.xy] / (float) ZIP,
        XYSum_B_R[DispatchThreadID.xy] / (float) ZIP
    );
    
    uint M = 0;
    for (int c = 0; c < 9; c++)
    {
        int2 CurrOffset = OffsetVector2D[c];
        uint2 AdjTallCell2DIndex = DispatchThreadID.xy + CurrOffset;
        
        if (any(AdjTallCell2DIndex < 0) || any(AdjTallCell2DIndex >= XZResolution))
            continue;

        uint AdjTallCellLinerIndex = computeMorton2D(AdjTallCell2DIndex);
        uint IntraParticleCount = HashGridCellParticleCount_R[AdjTallCellLinerIndex];
        
        M += IntraParticleCount;
    }
    
    float3 Sigma0 = (XXSum * YSum - XSum * XYSum) / (M * XXSum - pow(XSum, 2));
    float3 Sigma1 = (M * XYSum - XSum * YSum) / (M * XXSum - pow(XSum, 2));
    
    float CenterTerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float CenterTallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    float3 TopValue = Sigma0 + Sigma1 * (CenterTallCellHeight - 0.5f * CellLength);
    float3 BottomValue = Sigma0 + Sigma1 * 0.5f * CellLength;
    
    TopCellVelocity_RW[DispatchThreadID.xy] = TopValue;
    BottomCellVelocity_RW[DispatchThreadID.xy] = BottomValue;
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void gatherOnlyTallCellParticleToGrid(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float XSum = 0;
    float3 YSum = 0;
    float XXSum = 0;
    float3 XYSum = 0;
    uint M = 0;
    for (int c = 0; c < 9; c++)
    {
        int2 CurrOffset = OffsetVector2D[c];
        uint2 AdjTallCell2DIndex = DispatchThreadID.xy + CurrOffset;
        
        if (any(AdjTallCell2DIndex < 0) || any(AdjTallCell2DIndex >= XZResolution))
            continue;

        uint AdjTallCellLinerIndex = computeMorton2D(AdjTallCell2DIndex);
        uint IntraParticleCount = HashGridCellParticleCount_R[AdjTallCellLinerIndex];
        uint IntraParticleOffset = HashGridCellParticleOffset_R[AdjTallCellLinerIndex];
        for (int k = 0; k < IntraParticleCount; k++)
        {
            float3 CurrParticlePos = ParticlePosition_R[IntraParticleOffset + k];
            float3 CurrParticleVel = ParticleVelocity_R[IntraParticleOffset + k];
            float3 CenterCellPos = floor((CurrParticlePos - Min) / CellLength) * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
            float2 ContributePointXZ = CenterCellPos.xz - CurrOffset * CellLength;
            
            float Weight = CubicKernel(length(ContributePointXZ - CurrParticlePos.xz) / CellLength);
            float3 Y = Weight * CurrParticleVel;
            float X = CurrParticlePos.y - Min.y;
            XSum += X;
            YSum += Y;
            XXSum += pow(X, 2);
            XYSum += X * Y;
        }
        M += IntraParticleCount;
    }
    
    float3 Sigma0 = (XXSum * YSum - XSum * XYSum) / (M * XXSum - pow(XSum, 2));
    float3 Sigma1 = (M * XYSum - XSum * YSum) / (M * XXSum - pow(XSum, 2));
    
    float CenterTerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float CenterTallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    float3 TopValue = Sigma0 + Sigma1 * (CenterTallCellHeight - 0.5f * CellLength);
    float3 BottomValue = Sigma0 + Sigma1 * 0.5f * CellLength;
    
    TopCellVelocity_RW[DispatchThreadID.xy] = TopValue;
    BottomCellVelocity_RW[DispatchThreadID.xy] = BottomValue;
}