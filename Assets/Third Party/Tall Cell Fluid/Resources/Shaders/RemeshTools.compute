#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel computeTerrianHeight
#pragma kernel computeH1H2WithSeaLevel
#pragma kernel computeTallCellHeight
#pragma kernel smoothTallCellHeight
#pragma kernel enforceDCondition
#pragma kernel updateRegularCellVelocity
#pragma kernel updateTallCellVelocity
#pragma kernel updateSolidInfos

Texture2D<float> TerrianTexture_R;

Texture2D<float> TerrianHeight_R;
RWTexture2D<float> TerrianHeight_RW;

Texture2D<float2> WaterSurfaceH1H2_R;
RWTexture2D<float2> WaterSurfaceH1H2_RW;

Texture2D<float2> TallCellHeightMaxMin_R;
RWTexture2D<float2> TallCellHeightMaxMin_RW;

Texture2D<float> TallCellHeight_R;
RWTexture2D<float> TallCellHeight_RW;
RWTexture2D<float> TallCellHeightCache_RW;
SamplerState Sampler_Trilinear_Clamp;

float HeightScale;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeTerrianHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 UV = DispatchThreadID.xy / (float2) XZResolution;
    float TerrianHeight = TerrianTexture_R.SampleLevel(Sampler_Trilinear_Clamp, UV, 0);
    TerrianHeight = TerrianHeight * HeightScale;
    TerrianHeight = ceil(TerrianHeight / CellLength) * CellLength;
    TerrianHeight_RW[DispatchThreadID.xy] = TerrianHeight;
}

float SeaLevel;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeH1H2WithSeaLevel(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    WaterSurfaceH1H2_RW[DispatchThreadID.xy] = float2(TerrianHeight, SeaLevel > TerrianHeight ? SeaLevel : TerrianHeight);
}

uint GridLow;
uint GridAbove;
uint D;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeTallCellHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float2 H1H2 = WaterSurfaceH1H2_R[DispatchThreadID.xy];
    float RegularCellHeight = ConstantCellNum * CellLength;
    
    if (H1H2.y - H1H2.x > RegularCellHeight - CellLength * (GridAbove + GridLow))
    {
        float Min, Max;
        Min = Max = max(TerrianHeight, H1H2.y + GridAbove * CellLength - RegularCellHeight);
        TallCellHeightMaxMin_RW[DispatchThreadID.xy] = float2(Max, Min);
        TallCellHeight_RW[DispatchThreadID.xy] = (Max + Min) * 0.5f;
    }
    else
    {
        float Max = max(TerrianHeight, H1H2.x - CellLength * GridLow);
        float Min = max(TerrianHeight, H1H2.y + CellLength * GridAbove - RegularCellHeight);
        
        TallCellHeightMaxMin_RW[DispatchThreadID.xy] = float2(Max, Min);
        TallCellHeight_RW[DispatchThreadID.xy] = (Max + Min) * 0.5f;
    }
}

float BlurSigma;
float BlurRadius;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void smoothTallCellHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 UV = (float2) DispatchThreadID.xy / XZResolution;
    float2 h = 1.0f / XZResolution;
    float2 MaxMin = TallCellHeightMaxMin_R[DispatchThreadID.xy];
 
    const float2 offsets[9] =
    {
        float2(-1, 1), float2(0, 1), float2(1, 1),
	    float2(-1, 0), float2(0, 0), float2(1, 0),
		float2(-1, -1), float2(0, -1), float2(1, -1),
    };
    
    float sum = 0;
    float weight[9];
    for (int j = 0; j < 9; j++)
    {
        float l = length(BlurRadius * h * offsets[j]);
        float g = (1.0 / (2.0 * PI * pow(BlurSigma, 2.0))) * pow(E, (-(l * l) / (2.0 * pow(BlurSigma, 2.0))));
        weight[j] = g;
        sum += g;
    }

    for (j = 0; j < 9; j++)
        weight[j] /= sum;

    float Result = 0.0;
    for (j = 0; j < 9; j++)
    {
        Result += TallCellHeight_R.SampleLevel(Sampler_Trilinear_Clamp, UV + BlurRadius * h * offsets[j], 0) * weight[j];
    }
    TallCellHeightCache_RW[DispatchThreadID.xy] = clamp(Result, MaxMin.y, MaxMin.x);
}


[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void enforceDCondition(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 Center = TallCellHeight_R[DispatchThreadID.xy];
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float2 UV = (float2) DispatchThreadID.xy / XZResolution;
    float2 h = 1.0f / XZResolution;
    
    const float2 offsets[9] =
    {
        float2(-1, 1), float2(0, 1), float2(1, 1),
	    float2(-1, 0), float2(0, 0), float2(1, 0),
		float2(-1, -1), float2(0, -1), float2(1, -1),
    };
    float Max = -1.0f;
    for (int j = 0; j < 9; j++)
    {
        Max = max(Max, TallCellHeight_R.SampleLevel(Sampler_Trilinear_Clamp, UV + h * offsets[j], 0));
    }
    
    float FinalResult = min(Center, Max + D * CellLength) - TerrianHeight;
    FinalResult = (ceil(FinalResult / CellLength) + 2) * CellLength;
    TallCellHeightCache_RW[DispatchThreadID.xy] = FinalResult;
}

Texture2D<float> TerrrianHeight;
Texture2D<float> SrcTallCellHeight;
Texture2D<float> TallCellHeight;

Texture3D<float3> SrcRegularCellVelocity;
Texture2D<float3> SrcTallCellTopVelocity;
Texture2D<float3> SrcTallCellBottomVelocity;

RWTexture3D<float3> RegularCellVelocity;
[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void updateRegularCellVelocity(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    float CurrentHeight = TallCellHeight[DispatchThreadID.xz] + (DispatchThreadID.y + 0.5f) * CellLength;
    float LastFrameTallCellHeight = SrcTallCellHeight[DispatchThreadID.xz];
    float DistanceToLastFrameHeight = CurrentHeight - LastFrameTallCellHeight;

    if (DistanceToLastFrameHeight > 0)
    {
        uint3 LastFrameIndex = uint3(DispatchThreadID.x, DistanceToLastFrameHeight / CellLength, DispatchThreadID.z);
        RegularCellVelocity[DispatchThreadID] = SrcRegularCellVelocity[LastFrameIndex];
    }
    else
    {
        float LastFrameTallCellTopHeight = LastFrameTallCellHeight - 0.5f * CellLength;
        float LastFrameTallCellBottomHeight = TerrrianHeight[DispatchThreadID.xz] + 0.5f * CellLength;
        
        RegularCellVelocity[DispatchThreadID] =
            (SrcTallCellTopVelocity[DispatchThreadID.xz] - SrcTallCellBottomVelocity[DispatchThreadID.xz])
            / (LastFrameTallCellTopHeight - LastFrameTallCellBottomHeight) * (CurrentHeight - LastFrameTallCellBottomHeight)
            + SrcTallCellBottomVelocity[DispatchThreadID.xz];
    }
}

RWTexture2D<float3> TallCellTopVelocity;
RWTexture2D<float3> TallCellBottomVelocity;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void updateTallCellVelocity(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    float CurrentHeight = TallCellHeight[DispatchThreadID.xy] + 0.0001 * CellLength;
    float LastFrameTallCellHeight = SrcTallCellHeight[DispatchThreadID.xy];
    float TerrainHeight = TerrrianHeight[DispatchThreadID.xz];
    
    float LastFrameTallCellTopHeight = LastFrameTallCellHeight - 0.5f * CellLength;
    float LastFrameTallCellBottomHeight = TerrainHeight + 0.5f * CellLength;
    float LastFrameTallCellTopVelocity = SrcTallCellTopVelocity[DispatchThreadID.xz];
    float LastFrameTallCellBottomVelocity = SrcTallCellBottomVelocity[DispatchThreadID.xz];
    
    if (CurrentHeight - LastFrameTallCellHeight > 0)
    {
        float Sumx = 0;
        float Sumx2 = 0;
        float3 Sumy = 0;
        float3 Sumxy = 0;
        uint m = 2;
        
        Sumx += LastFrameTallCellTopHeight + LastFrameTallCellBottomHeight;
        Sumx2 += LastFrameTallCellTopHeight * LastFrameTallCellTopHeight + LastFrameTallCellBottomHeight * LastFrameTallCellBottomHeight;
        Sumy += LastFrameTallCellTopVelocity + LastFrameTallCellBottomVelocity;
        Sumxy += LastFrameTallCellTopHeight * LastFrameTallCellTopVelocity + LastFrameTallCellBottomHeight * LastFrameTallCellBottomVelocity;
        
        float RegularCellYCount = (CurrentHeight - LastFrameTallCellHeight) / CellLength;
        for (uint k = 0; k < RegularCellYCount; k++)
        {
            float LastFrameRegularCellHeight = LastFrameTallCellTopHeight + (k + 1) * CellLength;
            uint3 RegularIndex = uint3(DispatchThreadID.x, k, DispatchThreadID.y);

            Sumx += LastFrameRegularCellHeight;
            Sumx2 += LastFrameRegularCellHeight * RegularCellHeight;
            Sumy += SrcRegularCellVelocity[RegularIndex];
            Sumxy += LastFrameRegularCellHeight * SrcRegularCellVelocity[RegularIndex];
            m++;
        }
        
        float3 theta0 = Sumx2 * Sumy - Sumx * Sumxy;
        float3 theta1 = m * Sumxy - Sumx * Sumy;
        float theta2 = m * Sumx2 - Sumx * Sumx;
    
        float CurrentTopHeight = CurrentHeight - 0.5f * CellLength;
        float CurrentBottomHeight = TerrrianHeight[DispatchThreadID.xy] + 0.5f * CellLength;

        TallCellTopVelocity[DispatchThreadID.xy] = (theta0 * CurrentTopHeight + theta1) / theta2;
        TallCellBottomVelocity[DispatchThreadID.xy] = (theta0 * CurrentBottomHeight + theta1) / theta2;
    }
    else
    {
        RegularCellVelocity[DispatchThreadID] =
            (LastFrameTallCellTopVelocity - LastFrameTallCellBottomVelocity)
            / (LastFrameTallCellTopHeight - LastFrameTallCellBottomHeight) * (CurrentHeight - LastFrameTallCellBottomHeight)
            + LastFrameTallCellBottomVelocity;
        
        TallCellBottomVelocity[DispatchThreadID.xy] = SrcTallCellBottomVelocity[DispatchThreadID.xy];
    }
}

int RigidbodyNum;
Texture3D<float> SDF0;
Texture3D<float> SDF1;
Texture3D<float> SDF2;
Texture3D<float> SDF3;
struct RigidbodyInfo
{
    float4x4 m_WorldToObject;
    float3 m_Min;
    float3 m_BoundSize;
    float3 m_Pos;
    float3 m_Velocity;
    float3 m_AngularVelocity;
};
StructuredBuffer<RigidbodyInfo> RigidbodyInfos;

RWTexture3D<float> OutRegularCellRigidBodyPercentage;
RWTexture3D<float3> OutRegularCellRigidbodyVelocity;

float4 updateSolidInfo(float3 SamplePos, Texture3D<float> SDF, RigidbodyInfo RigidbodyInfo)
{
    float4 Result = float4(0, 0, 0, 0);
    float3 localPos = (mul(RigidbodyInfo.m_WorldToObject, float4(SamplePos, 1)).xyz - RigidbodyInfo.m_Min);
    if (any(localPos < 0))
        return Result;
    uint3 uvw = localPos / RigidbodyInfo.m_BoundSize * SDF_RESOLUTION;
    if (any(uvw > SDF_RESOLUTION - 1))
        return Result;
    Result.w = clamp((-SDF[uvw] + 0.5 * CellLength) / CellLength, 0, 1);
    if (Result.w > 0.01)
    {
        Result.xyz = RigidbodyInfo.m_Velocity + cross(RigidbodyInfo.m_AngularVelocity, (SamplePos - RigidbodyInfo.m_Pos));
    }
    return Result;
}

//TODO: ugly
[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void updateSolidInfos(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    float RigidbodyPercentage = 0;
    float3 RigidbodyVelocity = float3(0, 0, 0);
    float3 SamplePos = Min + (DispatchThreadID + float3(0.5, 0.5, 0.5)) * CellLength;
    SamplePos.y += TallCellHeight_R[DispatchThreadID.xz];
    
    float4 info;
    if (RigidbodyNum > 0)
    {
        info = updateSolidInfo(SamplePos, SDF0, RigidbodyInfos[0]);
        if (info.w > 0.01)
        {
            RigidbodyVelocity += info.xyz;
            RigidbodyPercentage += info.w;
        }
    }
    
    if (RigidbodyNum > 1)
    {
        info = updateSolidInfo(SamplePos, SDF1, RigidbodyInfos[1]);
        if (info.w > 0.01)
        {
            RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
            RigidbodyPercentage += info.w;
        }
    }
    
    if (RigidbodyNum > 2)
    {
        info = updateSolidInfo(SamplePos, SDF2, RigidbodyInfos[2]);
        if (info.w > 0.01)
        {
            RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
            RigidbodyPercentage += info.w;
        }
    }
    
    if (RigidbodyNum > 3)
    {
        info = updateSolidInfo(SamplePos, SDF3, RigidbodyInfos[3]);
        if (info.w > 0.01)
        {
            RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
            RigidbodyPercentage += info.w;
        }
    }
    
    OutRegularCellRigidbodyVelocity[DispatchThreadID] = RigidbodyVelocity;
    OutRegularCellRigidBodyPercentage[DispatchThreadID] = RigidbodyPercentage;
}