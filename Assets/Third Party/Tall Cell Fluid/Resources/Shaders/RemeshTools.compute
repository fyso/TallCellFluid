#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel computeTerrianHeight
#pragma kernel computeH1H2WithSeaLevel
#pragma kernel computeTallCellHeight
#pragma kernel smoothTallCellHeight
#pragma kernel enforceDCondition
#pragma kernel updateSolidInfos

Texture2D<float> TerrianTexture_R;

Texture2D<float> TerrianHeight_R;
RWTexture2D<float> TerrianHeight_RW;

Texture2D<float2> WaterSurfaceH1H2_R;
RWTexture2D<float2> WaterSurfaceH1H2_RW;

Texture2D<float2> TallCellHeightMaxMin_R;
RWTexture2D<float2> TallCellHeightMaxMin_RW;

Texture2D<float> TallCellHeight_R;
RWTexture2D<float> TallCellHeight_RW;
RWTexture2D<float> TallCellHeightCache_RW;
SamplerState Sampler_Trilinear_Clamp;

float HeightScale;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeTerrianHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 UV = DispatchThreadID.xy / (float2) XZResolution;
    float TerrianHeight = TerrianTexture_R.SampleLevel(Sampler_Trilinear_Clamp, UV, 0);
    TerrianHeight = TerrianHeight * HeightScale;
    TerrianHeight = ceil(TerrianHeight / CellLength) * CellLength;
    TerrianHeight_RW[DispatchThreadID.xy] = TerrianHeight;
}

float SeaLevel;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeH1H2WithSeaLevel(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    WaterSurfaceH1H2_RW[DispatchThreadID.xy] = float2(TerrianHeight, SeaLevel > TerrianHeight ? SeaLevel : TerrianHeight);
}

uint GridLow;
uint GridAbove;
uint D;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeTallCellHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float2 H1H2 = WaterSurfaceH1H2_R[DispatchThreadID.xy];
    float RegularCellHeight = ConstantCellNum * CellLength;
    
    if (H1H2.y - H1H2.x > RegularCellHeight - CellLength * (GridAbove + GridLow))
    {
        float Min, Max;
        Min = Max = max(TerrianHeight, H1H2.y + GridAbove * CellLength - RegularCellHeight);
        TallCellHeightMaxMin_RW[DispatchThreadID.xy] = float2(Max, Min);
        TallCellHeight_RW[DispatchThreadID.xy] = (Max + Min) * 0.5f;
    }
    else
    {
        float Max = max(TerrianHeight, H1H2.x - CellLength * GridLow);
        float Min = max(TerrianHeight, H1H2.y + CellLength * GridAbove - RegularCellHeight);
        
        TallCellHeightMaxMin_RW[DispatchThreadID.xy] = float2(Max, Min);
        TallCellHeight_RW[DispatchThreadID.xy] = (Max + Min) * 0.5f;
    }
}

float BlurSigma;
float BlurRadius;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void smoothTallCellHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 UV = (float2) DispatchThreadID.xy / XZResolution;
    float2 h = 1.0f / XZResolution;
    float2 MaxMin = TallCellHeightMaxMin_R[DispatchThreadID.xy];
 
    const float2 offsets[9] =
    {
        float2(-1, 1), float2(0, 1), float2(1, 1),
	    float2(-1, 0), float2(0, 0), float2(1, 0),
		float2(-1, -1), float2(0, -1), float2(1, -1),
    };
    
    float sum = 0;
    float weight[9];
    for (int j = 0; j < 9; j++)
    {
        float l = length(BlurRadius * h * offsets[j]);
        float g = (1.0 / (2.0 * PI * pow(BlurSigma, 2.0))) * pow(E, (-(l * l) / (2.0 * pow(BlurSigma, 2.0))));
        weight[j] = g;
        sum += g;
    }

    for (j = 0; j < 9; j++)
        weight[j] /= sum;

    float Result = 0.0;
    for (j = 0; j < 9; j++)
    {
        Result += TallCellHeight_R.SampleLevel(Sampler_Trilinear_Clamp, UV + BlurRadius * h * offsets[j], 0) * weight[j];
    }
    TallCellHeightCache_RW[DispatchThreadID.xy] = clamp(Result, MaxMin.y, MaxMin.x);
}


[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void enforceDCondition(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 Center = TallCellHeight_R[DispatchThreadID.xy];
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float2 UV = (float2) DispatchThreadID.xy / XZResolution;
    float2 h = 1.0f / XZResolution;
    
    const float2 offsets[9] =
    {
        float2(-1, 1), float2(0, 1), float2(1, 1),
	    float2(-1, 0), float2(0, 0), float2(1, 0),
		float2(-1, -1), float2(0, -1), float2(1, -1),
    };
    float Max = -1.0f;
    for (int j = 0; j < 9; j++)
    {
        Max = max(Max, TallCellHeight_R.SampleLevel(Sampler_Trilinear_Clamp, UV + h * offsets[j], 0));
    }
    
    float FinalResult = min(Center, Max + D * CellLength) - TerrianHeight;
    FinalResult = (ceil(FinalResult / CellLength) + 2) * CellLength;
    TallCellHeightCache_RW[DispatchThreadID.xy] = FinalResult;
}

int RigidbodyNum;
Texture3D<float> SDF0;
//Texture3D<float> SDF1;
//Texture3D<float> SDF2;
//Texture3D<float> SDF3;
struct RigidbodyInfo
{
    float4x4 m_WorldToObject;
    float3 m_Min;
    float3 m_BoundSize;
    float3 m_Pos;
    float3 m_Velocity;
    float3 m_AngularVelocity;
};
StructuredBuffer<RigidbodyInfo> RigidbodyInfos;

RWTexture3D<float> OutRegularCellRigidBodyPercentage;
RWTexture3D<float3> OutRegularCellRigidbodyVelocity;

float4 updateSolidInfo(float3 SamplePos, Texture3D<float> SDF, RigidbodyInfo RigidbodyInfo)
{
    uint3 uvw = (mul(RigidbodyInfo.m_WorldToObject, float4(SamplePos, 1)).xyz - RigidbodyInfo.m_Min) / RigidbodyInfo.m_BoundSize * SDF_RESOLUTION;
    float4 Result = float4(0, 0, 0, 0);
    if (any(uvw > SDF_RESOLUTION - 1))
        return Result;
    Result.w = clamp((-SDF[uvw] + 0.5 * CellLength) / CellLength, 0, 1);
    if (Result.w > 0.01)
    {
        Result.xyz = RigidbodyInfo.m_Velocity + cross(RigidbodyInfo.m_AngularVelocity, (SamplePos - RigidbodyInfo.m_Pos));
    }
    return Result;
}

//TODO: ugly
[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void updateSolidInfos(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    float RigidbodyPercentage = 0;
    float3 RigidbodyVelocity = float3(0, 0, 0);
    float3 SamplePos = Min + (DispatchThreadID + float3(0.5, 0.5, 0.5)) * CellLength;
    SamplePos.y += TallCellHeight_R[DispatchThreadID.xz];
    
    float4 info;
    if (RigidbodyNum > 0)
    {
        info = updateSolidInfo(SamplePos, SDF0, RigidbodyInfos[0]);
        if (info.w > 0.01)
        {
            RigidbodyVelocity += info.xyz;
            RigidbodyPercentage += info.w;
        }
    }
    
    //if (RigidbodyNum > 1)
    //{
    //    info = updateSolidInfo(SamplePos, SDF1, RigidbodyInfos[1]);
    //    if (info.w > 0.01)
    //    {
    //        RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
    //        RigidbodyPercentage += info.w;
    //    }
    //}
    
    //if (RigidbodyNum > 2)
    //{
    //    info = updateSolidInfo(SamplePos, SDF2, RigidbodyInfos[2]);
    //    if (info.w > 0.01)
    //    {
    //        RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
    //        RigidbodyPercentage += info.w;
    //    }
    //}
    
    //if (RigidbodyNum > 3)
    //{
    //    info = updateSolidInfo(SamplePos, SDF3, RigidbodyInfos[3]);
    //    if (info.w > 0.01)
    //    {
    //        RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
    //        RigidbodyPercentage += info.w;
    //    }
    //}
    
    OutRegularCellRigidbodyVelocity[DispatchThreadID] = RigidbodyVelocity;
    OutRegularCellRigidBodyPercentage[DispatchThreadID] = RigidbodyPercentage;
}