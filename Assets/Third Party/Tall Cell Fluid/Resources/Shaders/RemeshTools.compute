#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel computeTerrianHeight
#pragma kernel computeH1H2WithSeaLevel
#pragma kernel computeTallCellHeight
#pragma kernel smoothTallCellHeight
#pragma kernel enforceDCondition
#pragma kernel updateSolidInfos

Texture2D<float> TerrianTexture_R;

Texture2D<float> TerrianHeight_R;
RWTexture2D<float> TerrianHeight_RW;

Texture2D<float2> WaterSurfaceH1H2_R;
RWTexture2D<float2> WaterSurfaceH1H2_RW;

Texture2D<float2> TallCellHeightMaxMin_R;
RWTexture2D<float2> TallCellHeightMaxMin_RW;

Texture2D<float> TallCellHeight_R;
RWTexture2D<float> TallCellHeight_RW;
RWTexture2D<float> TallCellHeightCache_RW;
SamplerState Sampler_Trilinear_Clamp;

float HeightScale;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeTerrianHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 UV = DispatchThreadID.xy / (float2) XZResolution;
    float TerrianHeight = TerrianTexture_R.SampleLevel(Sampler_Trilinear_Clamp, UV, 0);
    TerrianHeight = TerrianHeight * HeightScale;
    TerrianHeight = ceil(TerrianHeight / CellLength) * CellLength;
    TerrianHeight_RW[DispatchThreadID.xy] = TerrianHeight;
}

float SeaLevel;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeH1H2WithSeaLevel(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    WaterSurfaceH1H2_RW[DispatchThreadID.xy] = float2(TerrianHeight, SeaLevel > TerrianHeight ? SeaLevel : TerrianHeight);
}

uint GridLow;
uint GridAbove;
uint D;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeTallCellHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float2 H1H2 = WaterSurfaceH1H2_R[DispatchThreadID.xy];
    float RegularCellHeight = ConstantCellNum * CellLength;
    
    if (H1H2.y - H1H2.x > RegularCellHeight - CellLength * (GridAbove + GridLow))
    {
        float Min, Max;
        Min = Max = max(TerrianHeight, H1H2.y + GridAbove * CellLength - RegularCellHeight);
        TallCellHeightMaxMin_RW[DispatchThreadID.xy] = float2(Max, Min);
        TallCellHeight_RW[DispatchThreadID.xy] = (Max + Min) * 0.5f;
    }
    else
    {
        float Max = max(TerrianHeight, H1H2.x - CellLength * GridLow);
        float Min = max(TerrianHeight, H1H2.y + CellLength * GridAbove - RegularCellHeight);
        
        TallCellHeightMaxMin_RW[DispatchThreadID.xy] = float2(Max, Min);
        TallCellHeight_RW[DispatchThreadID.xy] = (Max + Min) * 0.5f;
    }
}

float BlurSigma;
float BlurRadius;
[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void smoothTallCellHeight(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 UV = (float2) DispatchThreadID.xy / XZResolution;
    float2 h = 1.0f / XZResolution;
    float2 MaxMin = TallCellHeightMaxMin_R[DispatchThreadID.xy];
 
    const float2 offsets[9] =
    {
        float2(-1, 1), float2(0, 1), float2(1, 1),
	    float2(-1, 0), float2(0, 0), float2(1, 0),
		float2(-1, -1), float2(0, -1), float2(1, -1),
    };
    
    float sum = 0;
    float weight[9];
    for (int j = 0; j < 9; j++)
    {
        float l = length(BlurRadius * h * offsets[j]);
        float g = (1.0 / (2.0 * PI * pow(BlurSigma, 2.0))) * pow(E, (-(l * l) / (2.0 * pow(BlurSigma, 2.0))));
        weight[j] = g;
        sum += g;
    }

    for (j = 0; j < 9; j++)
        weight[j] /= sum;

    float Result = 0.0;
    for (j = 0; j < 9; j++)
    {
        Result += TallCellHeight_R.SampleLevel(Sampler_Trilinear_Clamp, UV + BlurRadius * h * offsets[j], 0) * weight[j];
    }
    TallCellHeightCache_RW[DispatchThreadID.xy] = clamp(Result, MaxMin.y, MaxMin.x);
}


[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void enforceDCondition(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy > XZResolution))
        return;
    
    float2 Center = TallCellHeight_R[DispatchThreadID.xy];
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float2 UV = (float2) DispatchThreadID.xy / XZResolution;
    float2 h = 1.0f / XZResolution;
    
    const float2 offsets[9] =
    {
        float2(-1, 1), float2(0, 1), float2(1, 1),
	    float2(-1, 0), float2(0, 0), float2(1, 0),
		float2(-1, -1), float2(0, -1), float2(1, -1),
    };
    float Max = -1.0f;
    for (int j = 0; j < 9; j++)
    {
        Max = max(Max, TallCellHeight_R.SampleLevel(Sampler_Trilinear_Clamp, UV + h * offsets[j], 0));
    }
    
    float FinalResult = min(Center, Max + D * CellLength) - TerrianHeight;
    FinalResult = (ceil(FinalResult / CellLength) + 2) * CellLength;
    TallCellHeightCache_RW[DispatchThreadID.xy] = FinalResult;
}

int RigidbodyNum;
Texture3D<float> SDF0;
Texture3D<float> SDF1;
Texture3D<float> SDF2;
Texture3D<float> SDF3;
struct RigidbodyInfo
{
    float4 m_Min;
    float4 m_Max;
    float4 m_Pos;
    float4 m_Velocity;
    float4 m_AngularVelocity;
};
RigidbodyInfo RigidbodyInfo0;
RigidbodyInfo RigidbodyInfo1;
RigidbodyInfo RigidbodyInfo2;
RigidbodyInfo RigidbodyInfo3;
RWTexture3D<float> OutRegularCellRigidBodyPercentage;
RWTexture3D<float3> OutRegularCellRigidbodyVelocity;

float4 updateSolidInfo(Texture3D<float> SDF, RigidbodyInfo RigidbodyInfo)
{
    return float4(0, 0, 0, 0);
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void updateSolidInfos(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    float RigidbodyPercentage = 0;
    float3 RigidbodyVelocity = float3(0, 0, 0);
    float4 info;
    info = updateSolidInfo(SDF0, RigidbodyInfo0);
    RigidbodyVelocity += info.xyz;
    RigidbodyPercentage += info.w;
    if (RigidbodyNum < 2)
    {
        OutRegularCellRigidbodyVelocity[DispatchThreadID] = RigidbodyVelocity;
        OutRegularCellRigidBodyPercentage[DispatchThreadID] = RigidbodyPercentage;
        return;
    }
    
    info = updateSolidInfo(SDF1, RigidbodyInfo1);
    RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
    RigidbodyPercentage += info.w;

    if (RigidbodyNum < 3)
    {
        OutRegularCellRigidbodyVelocity[DispatchThreadID] = RigidbodyVelocity;
        OutRegularCellRigidBodyPercentage[DispatchThreadID] = RigidbodyPercentage;
        return;
    }
    
    info = updateSolidInfo(SDF2, RigidbodyInfo2);
    RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
    RigidbodyPercentage += info.w;
    if (RigidbodyNum < 4)
    {
        OutRegularCellRigidbodyVelocity[DispatchThreadID] = RigidbodyVelocity;
        OutRegularCellRigidBodyPercentage[DispatchThreadID] = RigidbodyPercentage;
        return;
    }
    
    info = updateSolidInfo(SDF3, RigidbodyInfo3);
    RigidbodyVelocity = (RigidbodyVelocity * RigidbodyPercentage + info.xyz * info.w) / (RigidbodyPercentage + info.w);
    RigidbodyPercentage += info.w;
    

}