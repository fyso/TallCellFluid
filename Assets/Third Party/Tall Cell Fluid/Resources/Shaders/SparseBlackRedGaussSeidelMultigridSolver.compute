#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel computeVectorB_Regular
#pragma kernel computeVectorB_Top
#pragma kernel computeVectorB_Bottom
#pragma kernel applyNopressureForce
#pragma kernel smooth_RBGS_Regular
#pragma kernel smooth_RBGS_Top
#pragma kernel smooth_RBGS_Bottom
#pragma kernel residual_Regular
#pragma kernel residual_Top
#pragma kernel residual_Bottom
#pragma kernel restrict
#pragma kernel prolong
#pragma kernel updateVelocity_Regular
#pragma kernel updateVelocity_Top
#pragma kernel updateVelocity_Bottom

float Gravity;

Texture2D<float> TerrianHeight_R;
Texture2D<float> TallCellHeight_R;

Texture3D<float> RegularCellRigidBodyPercentage_R;
Texture2D<float> TopCellRigidBodyPercentage_R;
Texture2D<float> BottomRigidBodyPercentage_R;

Texture3D<float3> RegularCellRigidBodyVelocity_R;
Texture2D<float3> TopCellRigidBodyVelocity_R;
Texture2D<float3> BottomRigidBodyVelocity_R;

Texture3D<float3> RegularCellVelocity_R;
Texture2D<float3> TopCellVelocity_R;
Texture2D<float3> BottomCellVelocity_R;
RWTexture3D<float3> RegularCellVelocity_RW;
RWTexture2D<float3> TopCellVelocity_RW;
RWTexture2D<float3> BottomCellVelocity_RW;

Texture3D<float> RegularCellPressure_R;
Texture2D<float> TopCellPressure_R;
Texture2D<float> BottomCellPressure_R;
RWTexture3D<float> RegularCellPressure_RW;
RWTexture2D<float> TopCellPressure_RW;
RWTexture2D<float> BottomCellPressure_RW;

Texture3D<float> RegularCellPressure_Cache_R;
Texture2D<float> TopCellPressure_Cache_R;
Texture2D<float> BottomCellPressure_Cache_R;
RWTexture3D<float> RegularCellPressure_Cache_RW;
RWTexture2D<float> TopCellPressure_Cache_RW;
RWTexture2D<float> BottomCellPressure_Cache_RW;

Texture3D<float> VectorB_Regular_R;
Texture2D<float> VectorB_Top_R;
Texture2D<float> VectorB_Bottom_R;
RWTexture2D<float> VectorB_Top_RW;
RWTexture3D<float> VectorB_Regular_RW;
RWTexture2D<float> VectorB_Bottom_RW;

Texture3D<float> Residual_Regular_R;
Texture2D<float> Residual_Top_R;
Texture2D<float> Residual_Bottom_R;
RWTexture2D<float> Residual_Top_RW;
RWTexture3D<float> Residual_Regular_RW;
RWTexture2D<float> Residual_Bottom_RW;

Texture3D<int> RegularCellMark_R;

static int3 DivergenceOP[6] =
{
    { -1, 0, 0 },
    { 1, 0, 0 },
    { 0, -1, 0 },
    { 0, 1, 0 },
    { 0, 0, -1 },
    { 0, 0, 1 }
};

float3 getRegularCellCenterPosition(uint3 DispatchThreadID)
{
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xz];
    float TallCellHeight = TallCellHeight_R[DispatchThreadID.xz];
    float3 CenterCellPosition = DispatchThreadID * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
    CenterCellPosition.y += TerrianHeight + TallCellHeight;
    
    return CenterCellPosition;
}

float3 getTopCellCenterPosition(uint3 DispatchThreadID)
{
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float TallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    float2 CenterCellPositionXZ = DispatchThreadID.xy * CellLength + float2(0.5f, 0.5f) * CellLength;
    float3 CenterCellPosition = float3(CenterCellPositionXZ.x, TerrianHeight + TallCellHeight - 0.5f * CellLength, CenterCellPositionXZ.y);
    
    return CenterCellPosition;
}

float3 getBottomCellCenterPosition(uint3 DispatchThreadID)
{
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float TallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    float2 CenterCellPositionXZ = DispatchThreadID.xy * CellLength + float2(0.5f, 0.5f) * CellLength;
    float3 CenterCellPosition = float3(CenterCellPositionXZ.x, TerrianHeight + 0.5f * CellLength, CenterCellPositionXZ.y);
    
    return CenterCellPosition;
}

float computeVelocityDivergence(float3 CenterCellPosition, float3 CenterVelocity)
{
    float3 AdjCellVelocity[6];
    for (int c = 0; c < 6; c++)
    {
        float3 Position = CenterCellPosition + DivergenceOP[c];
        int2 XZ = floor(Position.xz / CellLength);
    
        float AdjTerrianHeight = TerrianHeight_R[XZ];
        float AdjTallCellHeight = TallCellHeight_R[XZ];
        if (any(XZ < 0) || any(XZ >= XZResolution) || Position.y >= AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
        {
            AdjCellVelocity[c] = CenterVelocity;
            //AdjCellVelocity[c] = float3(0, 0, 0);
            continue;
        }
    
        if (Position.y < AdjTerrianHeight)
        {
            AdjCellVelocity[c] = float3(0, 0, 0);
        }
        else if (Position.y >= AdjTerrianHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight)
        {
            float SolidFacctor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            if (SolidFacctor > 0.9f)
                AdjCellVelocity[c] = sampleTallCellValue(TopCellRigidBodyVelocity_R, BottomRigidBodyVelocity_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            else
                AdjCellVelocity[c] = (sampleTallCellValue(TopCellVelocity_R, BottomCellVelocity_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y) + CenterVelocity) * 0.5f;
        }
        else if (Position.y >= AdjTerrianHeight + AdjTallCellHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
        {
            int Y = (Position.y - (AdjTerrianHeight + AdjTallCellHeight)) / CellLength;
            float SolidFacctor = RegularCellRigidBodyPercentage_R[int3(XZ.x, Y, XZ.y)];
            if (SolidFacctor > 0.9f)
                AdjCellVelocity[c] = RegularCellRigidBodyVelocity_R[int3(XZ.x, Y, XZ.y)];
            else
                AdjCellVelocity[c] = (RegularCellVelocity_R[int3(XZ.x, Y, XZ.y)] + CenterVelocity) * 0.5f;
        }
    }
    
    return ((AdjCellVelocity[1].x - AdjCellVelocity[0].x) + (AdjCellVelocity[3].y - AdjCellVelocity[2].y) + (AdjCellVelocity[5].z - AdjCellVelocity[4].z)) / CellLength;
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void computeVectorB_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
    {
        VectorB_Regular_RW[DispatchThreadID] = 0;
        return;
    }
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xz] > 0.9f)
    {
        VectorB_Regular_RW[DispatchThreadID] = 0;
        return;
    }
    
    float3 CenterVelocity = RegularCellVelocity_R[DispatchThreadID];
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    
    VectorB_Regular_RW[DispatchThreadID] = -computeVelocityDivergence(CenterCellPosition, CenterVelocity);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeVectorB_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
    {
        VectorB_Top_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        VectorB_Top_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    float3 CenterVelocity = TopCellVelocity_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    
    VectorB_Top_RW[DispatchThreadID.xy] = -computeVelocityDivergence(CenterCellPosition, CenterVelocity);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeVectorB_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
    {
        VectorB_Bottom_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        VectorB_Bottom_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    float3 CenterVelocity = BottomCellVelocity_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    
    VectorB_Bottom_RW[DispatchThreadID.xy] = -computeVelocityDivergence(CenterCellPosition, CenterVelocity);
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void applyNopressureForce(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum + 2 || (DispatchThreadID.y > 1 && RegularCellMark_R[DispatchThreadID - uint3(0, 2, 0)] == 0))
        return;
    
    float SolidFactor = 0.0f;
    if (DispatchThreadID.y == 0)
        SolidFactor = BottomRigidBodyPercentage_R[DispatchThreadID.xz];
    else if (DispatchThreadID.y == 1)
        SolidFactor = TopCellRigidBodyPercentage_R[DispatchThreadID.xz];
    else
        SolidFactor = RegularCellRigidBodyPercentage_R[DispatchThreadID - uint3(0, 2, 0)];
    
    if (SolidFactor > 0.9f)
        return;
    
    uint3 Index3D = DispatchThreadID - uint3(0, 2, 0);
    if (DispatchThreadID.y == 0)
        BottomCellVelocity_RW[DispatchThreadID.xz] += float3(0.0f, -Gravity * TimeStep, 0.0f);
    else if (DispatchThreadID.y == 1)
        TopCellVelocity_RW[DispatchThreadID.xz] += float3(0.0f, -Gravity * TimeStep, 0.0f);
    else
        RegularCellVelocity_RW[Index3D] += float3(0.0f, -Gravity * TimeStep, 0.0f);
}

float doMatrixFreePressureProject(float3 CenterCellPosition, float CenterPressure, float B)
{
    float AdjPressureSum = 0.0f;
    int CurrPressureFactor = 0;
    for (int c = 0; c < 6; c++)
    {
        float3 Position = CenterCellPosition + DivergenceOP[c];
        int2 XZ = floor(Position.xz / CellLength);
        if (any(XZ < 0) || any(XZ >= XZResolution))
            continue;
    
        float AdjTerrianHeight = TerrianHeight_R[XZ];
        float AdjTallCellHeight = TallCellHeight_R[XZ];
    
        if (Position.y >= AdjTerrianHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight)
        {
            float AdjSolidFactor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            float AdjCellPressure = sampleTallCellValue(TopCellPressure_R, BottomCellPressure_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            AdjPressureSum += AdjSolidFactor * CenterPressure + (1 - AdjSolidFactor) * AdjCellPressure;
            CurrPressureFactor++;
        }
        else if (Position.y >= AdjTerrianHeight + AdjTallCellHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
        {
            int Y = (Position.y - (AdjTerrianHeight + AdjTallCellHeight)) / CellLength;
            int3 Index3D = int3(XZ.x, Y, XZ.y);
            float AdjSolidFactor = RegularCellRigidBodyPercentage_R[Index3D];
            float AdjCellPressure = RegularCellPressure_R[Index3D];
            int Mark = RegularCellMark_R[Index3D];
            if(Mark == 1)
                AdjPressureSum += AdjSolidFactor * CenterPressure + (1 - AdjSolidFactor) * AdjCellPressure;
            else
                AdjPressureSum += 0.0f;
            
            CurrPressureFactor++;
        }
        else if (Position.y < AdjTerrianHeight || Position.y >= 0)
        {
            AdjPressureSum += CenterPressure;
            CurrPressureFactor++;
        }
    }
    
    return (B * pow(CellLength, 2.0f) * Density0 / TimeStep + AdjPressureSum) / (float) CurrPressureFactor;
}

int RedBlackTrigger;

#define EBGS_CONDITION(CenterCellPosition)\
int3 Euler3DIndex = CenterCellPosition / CellLength;\
int EulerLinerIndex = Euler3DIndex.y * XZResolution.x * XZResolution.y + Euler3DIndex.z * XZResolution.x + Euler3DIndex.x;\
if (EulerLinerIndex % 2 == RedBlackTrigger)\
    return;\

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void smooth_RBGS_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
    {
        RegularCellPressure_Cache_RW[DispatchThreadID] = 0;
        return;
    }
    
    float CenterPressure = RegularCellPressure_R[DispatchThreadID];
    float CurrB = VectorB_Regular_R[DispatchThreadID];
    
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    
    EBGS_CONDITION(CenterCellPosition)

    RegularCellPressure_Cache_RW[DispatchThreadID] = doMatrixFreePressureProject(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void smooth_RBGS_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        TopCellPressure_Cache_RW[DispatchThreadID.xy] = 0.0f;
        return;
    }
    
    float CenterPressure = TopCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Top_R[DispatchThreadID.xy];
    
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    
    EBGS_CONDITION(CenterCellPosition)
    
    TopCellPressure_Cache_RW[DispatchThreadID.xy] = doMatrixFreePressureProject(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void smooth_RBGS_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float CenterPressure = BottomCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Bottom_R[DispatchThreadID.xy];
    
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    
    EBGS_CONDITION(CenterCellPosition)
    
    BottomCellPressure_Cache_RW[DispatchThreadID.xy] = doMatrixFreePressureProject(CenterCellPosition, CenterPressure, CurrB);
}

float computeResidual(float3 CenterCellPosition, float CenterPressure, float B)
{
    float AdjPressureSum = 0.0f;
    int CurrPressureFactor = 0;
    for (int c = 0; c < 6; c++)
    {
        float3 Position = CenterCellPosition + DivergenceOP[c];
        int2 XZ = floor(Position.xz / CellLength);
        if (any(XZ < 0) || any(XZ >= XZResolution))
            continue;
    
        float AdjTerrianHeight = TerrianHeight_R[XZ];
        float AdjTallCellHeight = TallCellHeight_R[XZ];
    
        if (Position.y >= AdjTerrianHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight)
        {
            float AdjSolidFactor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            float AdjCellPressure = sampleTallCellValue(TopCellPressure_R, BottomCellPressure_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            AdjPressureSum += AdjSolidFactor * CenterPressure + (1 - AdjSolidFactor) * AdjCellPressure;
            CurrPressureFactor++;
        }
        else if (Position.y >= AdjTerrianHeight + AdjTallCellHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
        {
            int Y = (Position.y - (AdjTerrianHeight + AdjTallCellHeight)) / CellLength;
            int3 Index3D = int3(XZ.x, Y, XZ.y);
            float AdjSolidFactor = RegularCellRigidBodyPercentage_R[Index3D];
            float AdjCellPressure = RegularCellPressure_R[Index3D];
            int Mark = RegularCellMark_R[Index3D];
            if (Mark == 1)
                AdjPressureSum += AdjSolidFactor * CenterPressure + (1 - AdjSolidFactor) * AdjCellPressure;
            else
                AdjPressureSum += 0.0f;
            
            CurrPressureFactor++;
        }
        else if (Position.y < AdjTerrianHeight)
        {
            AdjPressureSum += CenterPressure;
            CurrPressureFactor++;
        }
    }
    return B - (CurrPressureFactor * CenterPressure - AdjPressureSum) * TimeStep / Density0 / pow(CellLength, 2.0f);
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void residual_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
    {
        Residual_Regular_RW[DispatchThreadID] = 0;
        return;
    }
    float CenterPressure = RegularCellPressure_R[DispatchThreadID];
    float CurrB = VectorB_Regular_R[DispatchThreadID];
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    Residual_Regular_RW[DispatchThreadID] = computeResidual(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void residual_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        Residual_Top_RW[DispatchThreadID.xy] = 0.0f;
        return;
    }
    
    float CenterPressure = TopCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Top_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    Residual_Top_RW[DispatchThreadID.xy] = computeResidual(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void residual_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        Residual_Bottom_RW[DispatchThreadID.xy] = 0.0f;
        return;
    }
    
    float CenterPressure = BottomCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Bottom_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    Residual_Bottom_RW[DispatchThreadID.xy] = computeResidual(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void restrict(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void prolong(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    
}

float samplePressure(float3 CenterCellPosition, float CenterPressure, float3 Offset, out bool vNearTallCell)
{
    vNearTallCell = false;
    float3 Position = CenterCellPosition + Offset;
    int2 XZ = floor(Position.xz / CellLength);
    
    float ResultPressure = 0.0f;
    
    float AdjTerrianHeight = TerrianHeight_R[XZ];
    float AdjTallCellHeight = TallCellHeight_R[XZ];
    if (any(XZ < 0) || any(XZ >= XZResolution) || Position.y >= AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
    {
        ResultPressure = 0.0f;
    }
    else if (Position.y < AdjTerrianHeight)
    {
        //vNearTallCell = true;
        ResultPressure = CenterPressure;
    }
    else if (Position.y >= AdjTerrianHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight)
    {
        float SolidFactor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
        float Pressure = sampleTallCellValue(TopCellPressure_R, BottomCellPressure_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
        ResultPressure = SolidFactor * CenterPressure + (1 - SolidFactor) * Pressure;
    }
    else if (Position.y >= AdjTerrianHeight + AdjTallCellHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
    {
        int Y = (Position.y - (AdjTerrianHeight + AdjTallCellHeight)) / CellLength;
        int3 Index3D = int3(XZ.x, Y, XZ.y);
        float SolidFactor = RegularCellRigidBodyPercentage_R[Index3D];
        float Pressure = RegularCellPressure_R[Index3D];
        int Mark = RegularCellMark_R[Index3D];
        if (Mark == 1)
            ResultPressure = SolidFactor * CenterPressure + (1 - SolidFactor) * Pressure;
        else
            ResultPressure = 0.0f;
    }
    
    return ResultPressure;

}

float3 computePressureDivergence(float3 CenterCellPosition, float CenterPressure, float3 CenterVelocity)
{
    bool NearTallCell[6];
    float Left = samplePressure(CenterCellPosition, CenterPressure, float3(-1.0f, 0.0f, 0.0f) * CellLength, NearTallCell[0]);
    float Right = samplePressure(CenterCellPosition, CenterPressure, float3(1.0f, 0.0f, 0.0f) * CellLength, NearTallCell[1]);
    float Down = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, -1.0f, 0.0f) * CellLength, NearTallCell[2]);
    float Up = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, 1.0f, 0.0f) * CellLength, NearTallCell[3]);
    float Back = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, 0.0f, -1.0f) * CellLength, NearTallCell[4]);
    float Front = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, 0.0f, 1.0f) * CellLength, NearTallCell[5]);
    
    float3 Divergence = float3(Right - Left, Up - Down, Front - Back) / CellLength;
    
    if(NearTallCell[0] || NearTallCell[1])
        Divergence.x = CenterVelocity.x * Density0 / TimeStep;
    
    if (NearTallCell[2] || NearTallCell[3])
        Divergence.y = CenterVelocity.y * Density0 / TimeStep;
    
    if (NearTallCell[4] || NearTallCell[5])
        Divergence.z = CenterVelocity.z * Density0 / TimeStep;
    
    return Divergence;
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void updateVelocity_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
        return;
    
    float CenterPressure = RegularCellPressure_R[DispatchThreadID];
    float3 OldVelocity = RegularCellVelocity_RW[DispatchThreadID];
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    
    float3 PressureDivergence = computePressureDivergence(CenterCellPosition, CenterPressure, OldVelocity);
    RegularCellVelocity_RW[DispatchThreadID] = OldVelocity - TimeStep * PressureDivergence / Density0;
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void updateVelocity_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float CenterPressure = TopCellPressure_R[DispatchThreadID.xy];
    float3 OldVelocity = TopCellVelocity_RW[DispatchThreadID.xy];
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    
    float3 PressureDivergence = computePressureDivergence(CenterCellPosition, CenterPressure, OldVelocity);
    TopCellVelocity_RW[DispatchThreadID.xy] = OldVelocity - TimeStep * PressureDivergence / Density0;
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void updateVelocity_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float CenterPressure = BottomCellPressure_R[DispatchThreadID.xy];
    float3 OldVelocity = BottomCellVelocity_RW[DispatchThreadID.xy];
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    
    float3 PressureDivergence = computePressureDivergence(CenterCellPosition, CenterPressure, OldVelocity);
    BottomCellVelocity_RW[DispatchThreadID.xy] = OldVelocity - TimeStep * PressureDivergence / Density0;
}