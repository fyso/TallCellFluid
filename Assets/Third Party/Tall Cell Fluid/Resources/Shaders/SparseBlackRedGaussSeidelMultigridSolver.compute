#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel computeVectorB_Regular
#pragma kernel computeVectorB_Top
#pragma kernel computeVectorB_Bottom
#pragma kernel applyNopressureForce
#pragma kernel smooth_RBGS_Regular
#pragma kernel smooth_RBGS_Top
#pragma kernel smooth_RBGS_Bottom
#pragma kernel residual_Regular
#pragma kernel residual_Top
#pragma kernel residual_Bottom
#pragma kernel restrict_Regular
#pragma kernel restrict_Top
#pragma kernel restrict_Bottom
#pragma kernel prolong_Regular
#pragma kernel prolong_Top
#pragma kernel prolong_Bottom
#pragma kernel updateVelocity_Regular
#pragma kernel updateVelocity_Top
#pragma kernel updateVelocity_Bottom

float Gravity;

Texture2D<float> TerrianHeight_R;
Texture2D<float> TallCellHeight_R;

Texture3D<float> RegularCellRigidBodyPercentage_R;
Texture2D<float> TopCellRigidBodyPercentage_R;
Texture2D<float> BottomRigidBodyPercentage_R;

Texture3D<float3> RegularCellRigidBodyVelocity_R;
Texture2D<float3> TopCellRigidBodyVelocity_R;
Texture2D<float3> BottomRigidBodyVelocity_R;

Texture3D<float3> RegularCellVelocity_R;
Texture2D<float3> TopCellVelocity_R;
Texture2D<float3> BottomCellVelocity_R;
RWTexture3D<float3> RegularCellVelocity_RW;
RWTexture2D<float3> TopCellVelocity_RW;
RWTexture2D<float3> BottomCellVelocity_RW;

Texture3D<float> RegularCellPressure_R;
Texture2D<float> TopCellPressure_R;
Texture2D<float> BottomCellPressure_R;
RWTexture3D<float> RegularCellPressure_RW;
RWTexture2D<float> TopCellPressure_RW;
RWTexture2D<float> BottomCellPressure_RW;

Texture3D<float> RegularCellPressure_Cache_R;
Texture2D<float> TopCellPressure_Cache_R;
Texture2D<float> BottomCellPressure_Cache_R;
RWTexture3D<float> RegularCellPressure_Cache_RW;
RWTexture2D<float> TopCellPressure_Cache_RW;
RWTexture2D<float> BottomCellPressure_Cache_RW;

Texture3D<float> VectorB_Regular_R;
Texture2D<float> VectorB_Top_R;
Texture2D<float> VectorB_Bottom_R;
RWTexture2D<float> VectorB_Top_RW;
RWTexture3D<float> VectorB_Regular_RW;
RWTexture2D<float> VectorB_Bottom_RW;

Texture3D<float> Residual_Regular_R;
Texture2D<float> Residual_Top_R;
Texture2D<float> Residual_Bottom_R;
RWTexture2D<float> Residual_Top_RW;
RWTexture3D<float> Residual_Regular_RW;
RWTexture2D<float> Residual_Bottom_RW;

Texture3D<int> RegularCellMark_R;

static int3 DivergenceOP[6] =
{
    { -1, 0, 0 },
    { 1, 0, 0 },
    { 0, -1, 0 },
    { 0, 1, 0 },
    { 0, 0, -1 },
    { 0, 0, 1 }
};

float3 getRegularCellCenterPosition(uint3 DispatchThreadID)
{
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xz];
    float TallCellHeight = TallCellHeight_R[DispatchThreadID.xz];
    float3 CenterCellPosition = DispatchThreadID * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
    CenterCellPosition.y += TerrianHeight + TallCellHeight;
    
    return CenterCellPosition;
}

float3 getTopCellCenterPosition(uint3 DispatchThreadID)
{
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float TallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    float2 CenterCellPositionXZ = DispatchThreadID.xy * CellLength + float2(0.5f, 0.5f) * CellLength;
    float3 CenterCellPosition = float3(CenterCellPositionXZ.x, TerrianHeight + TallCellHeight - 0.5f * CellLength, CenterCellPositionXZ.y);
    
    return CenterCellPosition;
}

float3 getBottomCellCenterPosition(uint3 DispatchThreadID)
{
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xy];
    float TallCellHeight = TallCellHeight_R[DispatchThreadID.xy];
    float2 CenterCellPositionXZ = DispatchThreadID.xy * CellLength + float2(0.5f, 0.5f) * CellLength;
    float3 CenterCellPosition = float3(CenterCellPositionXZ.x, TerrianHeight + 0.5f * CellLength, CenterCellPositionXZ.y);
    
    return CenterCellPosition;
}

float buildPressureVectorb(float3 CenterCellPosition, float3 CenterVelocity, float VelocityDivergence)
{
    //float AdjTerrianHeight = 0.0f;
    //float AdjTallCellHeight = 0.0f;
    //float3 Position = CenterCellPosition + float3(-1, 0, 0) * CellLength;
    //int2 XZ = floor(Position.xz / CellLength);
    //if (!(any(XZ < 0) || any(XZ >= XZResolution)))
    //{
    //    AdjTerrianHeight = TerrianHeight_R[XZ];
    //    AdjTallCellHeight = TallCellHeight_R[XZ];
    //    if (Position.y < AdjTerrianHeight)
    //    {
    //        VelocityDivergence -= (CenterVelocity.x - 0.0f) / CellLength;
    //    }
    //}
    
    //Position = CenterCellPosition + float3(1, 0, 0) * CellLength;
    //XZ = floor(Position.xz / CellLength);
    //if (!(any(XZ < 0) || any(XZ >= XZResolution)))
    //{
    //    AdjTerrianHeight = TerrianHeight_R[XZ];
    //    AdjTallCellHeight = TallCellHeight_R[XZ];
    //    if (Position.y < AdjTerrianHeight)
    //    {
    //        VelocityDivergence += (CenterVelocity.x - 0.0f) / CellLength;
    //    }
    //}
    
    //Position = CenterCellPosition + float3(0, -1, 0) * CellLength;
    //XZ = floor(Position.xz / CellLength);
    //if (!(any(XZ < 0) || any(XZ >= XZResolution)))
    //{
    //    AdjTerrianHeight = TerrianHeight_R[XZ];
    //    AdjTallCellHeight = TallCellHeight_R[XZ];
    //    if (Position.y < AdjTerrianHeight)
    //    {
    //        VelocityDivergence -= (CenterVelocity.y - 0.0f) / CellLength;
    //    }
    //}
    
    //Position = CenterCellPosition + float3(0, 1, 0) * CellLength;
    //XZ = floor(Position.xz / CellLength);
    //if (!(any(XZ < 0) || any(XZ >= XZResolution)))
    //{
    //    AdjTerrianHeight = TerrianHeight_R[XZ];
    //    AdjTallCellHeight = TallCellHeight_R[XZ];
    //    if (Position.y < AdjTerrianHeight)
    //    {
    //        VelocityDivergence += (CenterVelocity.z - 0.0f) / CellLength;
    //    }
    //}
    
    //Position = CenterCellPosition + float3(0, 0, -1) * CellLength;
    //XZ = floor(Position.xz / CellLength);
    //if (!(any(XZ < 0) || any(XZ >= XZResolution)))
    //{
    //    AdjTerrianHeight = TerrianHeight_R[XZ];
    //    AdjTallCellHeight = TallCellHeight_R[XZ];
    //    if (Position.y < AdjTerrianHeight)
    //    {
    //        VelocityDivergence -= (CenterVelocity.z - 0.0f) / CellLength;
    //    }
    //}
    
    //Position = CenterCellPosition + float3(0, 0, 1) * CellLength;
    //XZ = floor(Position.xz / CellLength);
    //if (!(any(XZ < 0) || any(XZ >= XZResolution)))
    //{
    //    AdjTerrianHeight = TerrianHeight_R[XZ];
    //    AdjTallCellHeight = TallCellHeight_R[XZ];
    //    if (Position.y < AdjTerrianHeight)
    //    {
    //        VelocityDivergence += (CenterVelocity.z - 0.0f) / CellLength;
    //    }
    //}
    
    return VelocityDivergence;
}

float computeVectorB(float3 CenterCellPosition, float3 CenterVelocity)
{
    float3 AdjCellVelocity[6];
    for (int c = 0; c < 6; c++)
    {
        float3 Position = CenterCellPosition + DivergenceOP[c];
        int2 XZ = floor(Position.xz / CellLength);
    
        float AdjTerrianHeight = TerrianHeight_R[XZ];
        float AdjTallCellHeight = TallCellHeight_R[XZ];
        if (any(XZ < 0) || any(XZ >= XZResolution) || Position.y >= AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
        {
            AdjCellVelocity[c] = CenterVelocity;
        }
        else if (Position.y < AdjTerrianHeight)
        {
            AdjCellVelocity[c] = CenterVelocity;
        }
        else if (Position.y >= AdjTerrianHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight)
        {
            //float SolidFacctor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            //if (SolidFacctor > 0.9f)
            //    AdjCellVelocity[c] = sampleTallCellValue(TopCellRigidBodyVelocity_R, BottomRigidBodyVelocity_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            //else
            AdjCellVelocity[c] = (sampleTallCellValue(TopCellVelocity_R, BottomCellVelocity_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y) + CenterVelocity) * 0.5f;
        }
        else if (Position.y >= AdjTerrianHeight + AdjTallCellHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
        {
            int Y = (Position.y - (AdjTerrianHeight + AdjTallCellHeight)) / CellLength;
            //float SolidFacctor = RegularCellRigidBodyPercentage_R[int3(XZ.x, Y, XZ.y)];
            //if (SolidFacctor > 0.9f)
            //    AdjCellVelocity[c] = RegularCellRigidBodyVelocity_R[int3(XZ.x, Y, XZ.y)];
            //else
            AdjCellVelocity[c] = (RegularCellVelocity_R[int3(XZ.x, Y, XZ.y)] + CenterVelocity) * 0.5f;
        }
    }
    float VelDivergence = ((AdjCellVelocity[1].x - AdjCellVelocity[0].x) + (AdjCellVelocity[3].y - AdjCellVelocity[2].y) + (AdjCellVelocity[5].z - AdjCellVelocity[4].z)) / CellLength/* * Density0 / TimeStep*/;
    return buildPressureVectorb(CenterCellPosition, CenterVelocity, VelDivergence);
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void computeVectorB_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
    {
        VectorB_Regular_RW[DispatchThreadID] = 0;
        return;
    }
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xz] > 0.9f)
    {
        VectorB_Regular_RW[DispatchThreadID] = 0;
        return;
    }
    
    float3 CenterVelocity = RegularCellVelocity_R[DispatchThreadID];
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    
    VectorB_Regular_RW[DispatchThreadID] = computeVectorB(CenterCellPosition, CenterVelocity);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeVectorB_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
    {
        VectorB_Top_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        VectorB_Top_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    float3 CenterVelocity = TopCellVelocity_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    
    VectorB_Top_RW[DispatchThreadID.xy] = computeVectorB(CenterCellPosition, CenterVelocity);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void computeVectorB_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
    {
        VectorB_Bottom_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        VectorB_Bottom_RW[DispatchThreadID.xy] = 0;
        return;
    }
    
    float3 CenterVelocity = BottomCellVelocity_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    
    VectorB_Bottom_RW[DispatchThreadID.xy] = computeVectorB(CenterCellPosition, CenterVelocity);
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void applyNopressureForce(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum + 2 || (DispatchThreadID.y > 1 && RegularCellMark_R[DispatchThreadID - uint3(0, 2, 0)] == 0))
        return;
    
    float SolidFactor = 0.0f;
    if (DispatchThreadID.y == 0)
        SolidFactor = BottomRigidBodyPercentage_R[DispatchThreadID.xz];
    else if (DispatchThreadID.y == 1)
        SolidFactor = TopCellRigidBodyPercentage_R[DispatchThreadID.xz];
    else
        SolidFactor = RegularCellRigidBodyPercentage_R[DispatchThreadID - uint3(0, 2, 0)];
    
    if (SolidFactor > 0.9f)
        return;
    
    uint3 Index3D = DispatchThreadID - uint3(0, 2, 0);
    if (DispatchThreadID.y == 0)
        BottomCellVelocity_RW[DispatchThreadID.xz] += float3(0.0f, -Gravity * TimeStep, 0.0f);
    else if (DispatchThreadID.y == 1)
        TopCellVelocity_RW[DispatchThreadID.xz] += float3(0.0f, -Gravity * TimeStep, 0.0f);
    else
        RegularCellVelocity_RW[Index3D] += float3(0.0f, -Gravity * TimeStep, 0.0f);
}

void computeDataSum(float3 CenterCellPosition, float CenterPressure, out float AdjPressureSum, out int CurrPressureFactor)
{
    AdjPressureSum = 0.0f;
    CurrPressureFactor = 0;
    for (int c = 0; c < 6; c++)
    {
        float3 Position = CenterCellPosition + DivergenceOP[c];
        int2 XZ = floor(Position.xz / CellLength);
        
        float AdjTerrianHeight = TerrianHeight_R[XZ];
        float AdjTallCellHeight = TallCellHeight_R[XZ];
        if (any(XZ < 0) || any(XZ >= XZResolution))
            continue;
    
        if (Position.y >= AdjTerrianHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight)
        {
            float AdjSolidFactor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            float AdjCellPressure = sampleTallCellValue(TopCellPressure_R, BottomCellPressure_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
            //AdjPressureSum += AdjSolidFactor * CenterPressure + (1 - AdjSolidFactor) * AdjCellPressure;
            AdjPressureSum += AdjCellPressure;
            CurrPressureFactor++;
        }
        else if (Position.y >= AdjTerrianHeight + AdjTallCellHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
        {
            int Y = (Position.y - (AdjTerrianHeight + AdjTallCellHeight)) / CellLength;
            int3 Index3D = int3(XZ.x, Y, XZ.y);
            float AdjSolidFactor = RegularCellRigidBodyPercentage_R[Index3D];
            float AdjCellPressure = RegularCellPressure_R[Index3D];
            int Mark = RegularCellMark_R[Index3D];
            if (Mark == 1)
            {
                //AdjPressureSum += AdjSolidFactor * CenterPressure + (1 - AdjSolidFactor) * AdjCellPressure;
                AdjPressureSum += AdjCellPressure;
                CurrPressureFactor++;
            }
            else
            {
                AdjPressureSum += 0.0f;
                CurrPressureFactor++;
            }
        }
    }
}

float doMatrixFreePressureProject(float3 CenterCellPosition, float CenterPressure, float B)
{
    float AdjPressureSum = 0.0f;
    int CurrPressureFactor = 0;
    computeDataSum(CenterCellPosition, CenterPressure, AdjPressureSum, CurrPressureFactor);
    //if(CurrPressureFactor != 0)
        return (AdjPressureSum - B * pow(CellLength, 2.0f)) / (float) CurrPressureFactor;
    //else
    //    return CenterPressure;
}

float computeResidual(float3 CenterCellPosition, float CenterPressure, float B)
{
    float AdjPressureSum = 0.0f;
    int CurrPressureFactor = 0;
    computeDataSum(CenterCellPosition, CenterPressure, AdjPressureSum, CurrPressureFactor);
    return B - (AdjPressureSum - CurrPressureFactor * CenterPressure) / pow(CellLength, 2.0f);
}

int RedBlackTrigger;

#define EBGS_CONDITION(CenterCellPositionre, CenterPressure, Target)\
int3 Euler3DIndex = CenterCellPosition / CellLength;\
bool XIndexIsOdd = Euler3DIndex.x % 2 == RedBlackTrigger;\
bool YIndexIsOdd = Euler3DIndex.y % 2 == RedBlackTrigger;\
bool ZIndexIsOdd = Euler3DIndex.z % 2 == RedBlackTrigger;\
if ((XIndexIsOdd && YIndexIsOdd && ZIndexIsOdd) || (!XIndexIsOdd && !YIndexIsOdd && ZIndexIsOdd) || (XIndexIsOdd && !YIndexIsOdd && !ZIndexIsOdd) || (!XIndexIsOdd && YIndexIsOdd && !ZIndexIsOdd))\
{\
    Target = CenterPressure;\
    return;\
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void smooth_RBGS_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
    {
        RegularCellPressure_Cache_RW[DispatchThreadID] = 0;
        return;
    }
    
    float CenterPressure = RegularCellPressure_R[DispatchThreadID];
    float CurrB = VectorB_Regular_R[DispatchThreadID];
    
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    
    EBGS_CONDITION(CenterCellPosition, CenterPressure, RegularCellPressure_Cache_RW[DispatchThreadID])

    RegularCellPressure_Cache_RW[DispatchThreadID] = doMatrixFreePressureProject(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void smooth_RBGS_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        TopCellPressure_Cache_RW[DispatchThreadID.xy] = 0.0f;
        return;
    }
    
    float CenterPressure = TopCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Top_R[DispatchThreadID.xy];
    
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    
    EBGS_CONDITION(CenterCellPosition, CenterPressure, TopCellPressure_Cache_RW[DispatchThreadID.xy])
    
    TopCellPressure_Cache_RW[DispatchThreadID.xy] = doMatrixFreePressureProject(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void smooth_RBGS_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        BottomCellPressure_Cache_RW[DispatchThreadID.xy] = 0.0f;
        return;
    }
    
    float CenterPressure = BottomCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Bottom_R[DispatchThreadID.xy];
    
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    
    EBGS_CONDITION(CenterCellPosition, CenterPressure, BottomCellPressure_Cache_RW[DispatchThreadID.xy])
    
    BottomCellPressure_Cache_RW[DispatchThreadID.xy] = doMatrixFreePressureProject(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void residual_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
    {
        Residual_Regular_RW[DispatchThreadID] = 0;
        return;
    }
    
    float CenterPressure = RegularCellPressure_R[DispatchThreadID];
    float CurrB = VectorB_Regular_R[DispatchThreadID];
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    Residual_Regular_RW[DispatchThreadID] = computeResidual(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void residual_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        Residual_Top_RW[DispatchThreadID.xy] = 0.0f;
        return;
    }
    
    float CenterPressure = TopCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Top_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    Residual_Top_RW[DispatchThreadID.xy] = computeResidual(CenterCellPosition, CenterPressure, CurrB);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void residual_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
    {
        Residual_Bottom_RW[DispatchThreadID.xy] = 0.0f;
        return;
    }
    
    float CenterPressure = BottomCellPressure_R[DispatchThreadID.xy];
    float CurrB = VectorB_Bottom_R[DispatchThreadID.xy];
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    Residual_Bottom_RW[DispatchThreadID.xy] = computeResidual(CenterCellPosition, CenterPressure, CurrB);
}

Texture3D<float> Higher_Residual_Regular_R;
Texture2D<float> Higher_Residual_Top_R;
Texture2D<float> Higher_Residual_Bottom_R;

Texture2D<float> Higher_TerrianHeight_R;
Texture2D<float> Higher_TallCellHeight_R;

float Higher_CellLength;
uint2 Higher_XZResolution;
uint Higher_ConstantCellNum;

float sampleHigherResidual(float3 vCenterPosition)
{
    float WeightSum = 0.0f;
    float WeightResidualSum = 0.0f;
    for (int i = 0; i < 27; i++)
    {
        float3 AdjPointPosition = vCenterPosition + OffsetVector3D[i] * Higher_CellLength;
        float Weight = CubicKernel(length(AdjPointPosition - vCenterPosition) / Higher_CellLength);
        int2 AdjXZ = AdjPointPosition.xz / Higher_CellLength;
        if (any(AdjXZ < 0) || any(AdjXZ >= Higher_XZResolution))
            continue;
        
        float AdjTerrianHeight = Higher_TerrianHeight_R[AdjXZ];
        float AdjTallCellHeight = Higher_TallCellHeight_R[AdjXZ];
        if (AdjPointPosition.y >= AdjTerrianHeight + AdjTallCellHeight && AdjPointPosition.y < AdjTerrianHeight + AdjTallCellHeight + Higher_ConstantCellNum * Higher_CellLength)
        {
            uint YIndex = (AdjPointPosition.y - AdjTerrianHeight - AdjTallCellHeight) / Higher_CellLength;
            WeightResidualSum += Weight * Higher_Residual_Regular_R[uint3(AdjXZ.x, YIndex, AdjXZ.y)];
            WeightSum += Weight;
        }
        else if (AdjPointPosition.y >= AdjTerrianHeight && AdjPointPosition.y < AdjTerrianHeight + AdjTallCellHeight)
        {
            if (abs(AdjPointPosition.y - (AdjTerrianHeight + 0.5f * Higher_CellLength)) < EPSILON)
            {
                WeightResidualSum += Weight * Higher_Residual_Bottom_R[AdjXZ];
                WeightSum += Weight;
            }
            else if (abs(AdjPointPosition.y - (AdjTallCellHeight - 0.5f * Higher_CellLength)) < EPSILON)
            {
                WeightResidualSum += Weight * Higher_Residual_Top_R[AdjXZ];
                WeightSum += Weight;
            }
        }
    }
    
    if (abs(WeightSum - 0.0f) < EPSILON)
        return 0.0f;
    return WeightResidualSum / (WeightSum + EPSILON);
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void restrict_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
        return;
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    VectorB_Regular_RW[DispatchThreadID] = sampleHigherResidual(CenterCellPosition);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void restrict_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    VectorB_Top_RW[DispatchThreadID.xy] = sampleHigherResidual(CenterCellPosition);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void restrict_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    VectorB_Bottom_RW[DispatchThreadID.xy] = sampleHigherResidual(CenterCellPosition);
}

Texture3D<float> Lower_Pressure_Regular_R;
Texture2D<float> Lower_Pressure_Top_R;
Texture2D<float> Lower_Pressure_Bottom_R;

Texture2D<float> Lower_TerrianHeight_R;
Texture2D<float> Lower_TallCellHeight_R;

float Lower_CellLength;
uint2 Lower_XZResolution;
uint Lower_ConstantCellNum;

float sampleLowerPressure(float3 vCenterPosition)
{
    float WeightSum = 0.0f;
    float WeightPressureSum = 0.0f;
    for (int i = 0; i < 27; i++)
    {
        float3 AdjPointPosition = vCenterPosition + OffsetVector3D[i] * Lower_CellLength;
        float Weight = CubicKernel(length(AdjPointPosition - vCenterPosition) / Lower_CellLength);
        int2 AdjXZ = AdjPointPosition.xz / Lower_CellLength;
        if (any(AdjXZ < 0) || any(AdjXZ >= Lower_XZResolution))
            continue;
        
        float AdjTerrianHeight = Lower_TerrianHeight_R[AdjXZ];
        float AdjTallCellHeight = Lower_TallCellHeight_R[AdjXZ];
        if (AdjPointPosition.y >= AdjTerrianHeight + AdjTallCellHeight && AdjPointPosition.y < AdjTerrianHeight + AdjTallCellHeight + Lower_ConstantCellNum * Lower_CellLength)
        {
            uint YIndex = (AdjPointPosition.y - AdjTerrianHeight - AdjTallCellHeight) / Lower_CellLength;
            WeightPressureSum += Weight * Lower_Pressure_Regular_R[uint3(AdjXZ.x, YIndex, AdjXZ.y)];
            WeightSum += Weight;
        }
        else if (AdjPointPosition.y >= AdjTerrianHeight && AdjPointPosition.y < AdjTerrianHeight + AdjTallCellHeight)
        {
            float Pressure = sampleTallCellValue(Lower_Pressure_Top_R, Lower_Pressure_Bottom_R, AdjTerrianHeight, AdjTallCellHeight, AdjXZ, AdjPointPosition.y);
            WeightPressureSum += Weight * Pressure;
            WeightSum += Weight;
        }
    }
    
    if (abs(WeightSum - 0.0f) < EPSILON)
        return 0.0f;
    return WeightPressureSum / (WeightSum + EPSILON);
}

bool ShouldOverWrite;
[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void prolong_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
        return;
    
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    if (ShouldOverWrite)
        RegularCellPressure_RW[DispatchThreadID] = sampleLowerPressure(CenterCellPosition);
    else
        RegularCellPressure_RW[DispatchThreadID] += sampleLowerPressure(CenterCellPosition);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void prolong_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    if (ShouldOverWrite)
        TopCellPressure_RW[DispatchThreadID.xy] = sampleLowerPressure(CenterCellPosition);
    else
        TopCellPressure_RW[DispatchThreadID.xy] += sampleLowerPressure(CenterCellPosition);
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void prolong_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    if (ShouldOverWrite)
        BottomCellPressure_RW[DispatchThreadID.xy] = sampleLowerPressure(CenterCellPosition);
    else
        BottomCellPressure_RW[DispatchThreadID.xy] += sampleLowerPressure(CenterCellPosition);
}

float samplePressure(float3 CenterCellPosition, float CenterPressure, float3 Offset, out bool vNearTallCell)
{
    vNearTallCell = false;
    float3 Position = CenterCellPosition + Offset;
    int2 XZ = floor(Position.xz / CellLength);
    
    float ResultPressure = 0.0f;
    
    float AdjTerrianHeight = TerrianHeight_R[XZ];
    float AdjTallCellHeight = TallCellHeight_R[XZ];
    if (any(XZ < 0) || any(XZ >= XZResolution) || Position.y >= AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength || Position.y < 0.0f)
    {
        //clamp(XZ, int2(0, 0), XZResolution);
        //clamp(Position.y, 0, AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength);
        ResultPressure = CenterPressure;
    }
    else if (Position.y >= AdjTerrianHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight)
    {
        //float SolidFactor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
        //float Pressure = sampleTallCellValue(TopCellPressure_R, BottomCellPressure_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
        ResultPressure = sampleTallCellValue(TopCellPressure_R, BottomCellPressure_R, AdjTerrianHeight, AdjTallCellHeight, XZ, Position.y);
        //ResultPressure = SolidFactor * CenterPressure + (1 - SolidFactor) * Pressure;
    }
    else if (Position.y >= AdjTerrianHeight + AdjTallCellHeight && Position.y < AdjTerrianHeight + AdjTallCellHeight + ConstantCellNum * CellLength)
    {
        int Y = (Position.y - (AdjTerrianHeight + AdjTallCellHeight)) / CellLength;
        int3 Index3D = int3(XZ.x, Y, XZ.y);
        float SolidFactor = RegularCellRigidBodyPercentage_R[Index3D];
        float Pressure = RegularCellPressure_R[Index3D];
        int Mark = RegularCellMark_R[Index3D];
        if (Mark == 1)
            ResultPressure = SolidFactor * CenterPressure + (1 - SolidFactor) * Pressure;
        else
            ResultPressure = CenterPressure;
    }
    else if (Position.y < AdjTerrianHeight)
    {
        vNearTallCell = true;
        ResultPressure = 0.0f;
    }
    
    return ResultPressure;
}

float3 computePressureDivergence(float3 CenterCellPosition, float CenterPressure, float3 CenterVelocity)
{
    bool NearTallCell[6];
    float Left = samplePressure(CenterCellPosition, CenterPressure, float3(-1.0f, 0.0f, 0.0f) * CellLength, NearTallCell[0]);
    float Right = samplePressure(CenterCellPosition, CenterPressure, float3(1.0f, 0.0f, 0.0f) * CellLength, NearTallCell[1]);
    float Down = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, -1.0f, 0.0f) * CellLength, NearTallCell[2]);
    float Up = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, 1.0f, 0.0f) * CellLength, NearTallCell[3]);
    float Back = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, 0.0f, -1.0f) * CellLength, NearTallCell[4]);
    float Front = samplePressure(CenterCellPosition, CenterPressure, float3(0.0f, 0.0f, 1.0f) * CellLength, NearTallCell[5]);
    
    float3 Divergence = float3(Right - Left, Up - Down, Front - Back) / CellLength;
    
    //if (NearTallCell[0] && CenterVelocity.x < 0.0f)
    //    Divergence.x = CenterVelocity.x/* * Density0 / TimeStep*/;
    
    //if (NearTallCell[1] && CenterVelocity.x > 0.0f)
    //    Divergence.x = CenterVelocity.x/* * Density0 / TimeStep*/;
    
    //if (NearTallCell[2] && CenterVelocity.y < 0.0f)
    //    Divergence.y = CenterVelocity.y/* * Density0 / TimeStep*/;
    
    //if (NearTallCell[3] && CenterVelocity.y > 0.0f)
    //    Divergence.y = CenterVelocity.y/* * Density0 / TimeStep*/;
    
    //if (NearTallCell[4] && CenterVelocity.z < 0.0f)
    //    Divergence.z = CenterVelocity.z/* * Density0 / TimeStep*/;
    
    //if (NearTallCell[5] && CenterVelocity.z > 0.0f)
    //    Divergence.z = CenterVelocity.z/* * Density0 / TimeStep*/;
    
    if (NearTallCell[0] || NearTallCell[1])
        Divergence.x = CenterVelocity.x;
    
    if (NearTallCell[2] || NearTallCell[3])
        Divergence.y = CenterVelocity.y;
    
    if (NearTallCell[4] || NearTallCell[5])
        Divergence.z = CenterVelocity.z;
    
    return Divergence;
}

[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void updateVelocity_Regular(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum || RegularCellMark_R[DispatchThreadID] != 1)
        return;
    
    if (RegularCellRigidBodyPercentage_R[DispatchThreadID] > 0.9f)
        return;
    
    float CenterPressure = RegularCellPressure_R[DispatchThreadID];
    float3 OldVelocity = RegularCellVelocity_RW[DispatchThreadID];
    float3 CenterCellPosition = getRegularCellCenterPosition(DispatchThreadID);
    
    float3 PressureDivergence = computePressureDivergence(CenterCellPosition, CenterPressure, OldVelocity);
    RegularCellVelocity_RW[DispatchThreadID] = OldVelocity - PressureDivergence;
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void updateVelocity_Top(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (TopCellRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float CenterPressure = TopCellPressure_R[DispatchThreadID.xy];
    float3 OldVelocity = TopCellVelocity_RW[DispatchThreadID.xy];
    float3 CenterCellPosition = getTopCellCenterPosition(DispatchThreadID);
    
    float3 PressureDivergence = computePressureDivergence(CenterCellPosition, CenterPressure, OldVelocity);
    TopCellVelocity_RW[DispatchThreadID.xy] = OldVelocity - PressureDivergence;
}

[numthreads(THREAD_COUNT_2D, THREAD_COUNT_2D, 1)]
void updateVelocity_Bottom(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xy >= XZResolution))
        return;
    
    if (BottomRigidBodyPercentage_R[DispatchThreadID.xy] > 0.9f)
        return;
    
    float CenterPressure = BottomCellPressure_R[DispatchThreadID.xy];
    float3 OldVelocity = BottomCellVelocity_RW[DispatchThreadID.xy];
    float3 CenterCellPosition = getBottomCellCenterPosition(DispatchThreadID);
    
    float3 PressureDivergence = computePressureDivergence(CenterCellPosition, CenterPressure, OldVelocity);
    BottomCellVelocity_RW[DispatchThreadID.xy] = OldVelocity - PressureDivergence;
}