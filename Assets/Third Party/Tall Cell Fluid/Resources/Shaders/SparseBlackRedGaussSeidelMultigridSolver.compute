#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel computeVectorB
#pragma kernel smooth
#pragma kernel restrict
#pragma kernel prolong

Texture2D<float> TerrianHeight_R;
Texture2D<float> TallCellHeight_R;

Texture3D<float3> RegularCellVelocity_R;
Texture2D<float3> TopCellVelocity_R;
Texture2D<float3> BottomCellVelocity_R;

Texture3D<float> RegularCellRigidBodyPercentage_R;
Texture2D<float> TopCellRigidBodyPercentage_R;
Texture2D<float> BottomRigidBodyPercentage_R;

Texture3D<float3> RegularCellRigidBodyVelocity_R;
Texture2D<float3> TopCellRigidBodyVelocity_R;
Texture2D<float3> BottomRigidBodyVelocity_R;

Texture3D<int> RegularCellMark_R;

float3 sampleTallCellGrid(float3 vCenterPosition, float3 vOffset, float3 CenterValue)
{
    float3 Position = vCenterPosition + vOffset;
    int2 XZ = clamp(Position.xz / CellLength, int2(0, 0), XZResolution - int2(1, 1));
    
    float TerrianHeight = TerrianHeight_R[XZ];
    float TallCellHeight = TallCellHeight_R[XZ];
    
    float3 Velocity = float3(0, 0, 0);
    if (Position.y >= TerrianHeight && Position.y < TerrianHeight + TallCellHeight)
    {
        float SolidFacctor = sampleTallCellValue(TopCellRigidBodyPercentage_R, BottomRigidBodyPercentage_R, TerrianHeight, TallCellHeight, XZ, Position.y);
        if(SolidFacctor > 0.9f)
            Velocity = sampleTallCellValue(TopCellRigidBodyVelocity_R, BottomRigidBodyVelocity_R, TerrianHeight, TallCellHeight, XZ, Position.y);
        else
            Velocity = (sampleTallCellValue(TopCellVelocity_R, BottomCellVelocity_R, TerrianHeight, TallCellHeight, XZ, Position.y) + CenterValue) * 0.5f;
    }
    else if (Position.y >= TerrianHeight + TallCellHeight && Position.y < TerrianHeight + TallCellHeight + ConstantCellNum * CellLength)
    {
        int Y = (Position.y - (TerrianHeight + TallCellHeight)) / CellLength;
        float SolidFacctor = RegularCellRigidBodyPercentage_R[int3(XZ.x, Y, XZ.y)];
        if (SolidFacctor > 0.9f)
            Velocity = RegularCellRigidBodyVelocity_R[int3(XZ.x, Y, XZ.y)];
        else
            Velocity = (RegularCellVelocity_R[int3(XZ.x, Y, XZ.y)] + CenterValue) * 0.5f;
    }
    else if (Position.y >= TerrianHeight + TallCellHeight + ConstantCellNum * CellLength)
    {
        Velocity = CenterValue;
    }
    else
    {
        Velocity = float3(0, 0, 0);
    }
    return Velocity;
}

RWTexture3D<float> VectorB_RW;
[numthreads(THREAD_COUNT_3D, THREAD_COUNT_3D, THREAD_COUNT_3D)]
void computeVectorB(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    if (any(DispatchThreadID.xz >= XZResolution) || DispatchThreadID.y >= ConstantCellNum + 2 || (DispatchThreadID.y > 1 && RegularCellMark_R[DispatchThreadID - uint3(0, 2, 0)] == 0))
    {
        VectorB_RW[DispatchThreadID] = 0;
        return;
    }
    
    
    float TerrianHeight = TerrianHeight_R[DispatchThreadID.xz];
    float TallCellHeight = TallCellHeight_R[DispatchThreadID.xz];
    
    float SolidFactor = 0.0f;
    if (DispatchThreadID.y == 0)
        SolidFactor = BottomRigidBodyPercentage_R[DispatchThreadID.xz];
    else if (DispatchThreadID.y == 1)
        SolidFactor = TopCellRigidBodyPercentage_R[DispatchThreadID.xz];
    else
        SolidFactor = RegularCellRigidBodyPercentage_R[DispatchThreadID - uint3(0, 2, 0)];
    
    if(SolidFactor > 0.9f)
        return;
    
    float3 CenterVelocity, CenterCellPosition = float3(0, 0, 0);
    if(DispatchThreadID.y == 0)
    {
        CenterVelocity = BottomCellVelocity_R[DispatchThreadID.xz];
        float2 XZ = DispatchThreadID.xz * CellLength + float2(0.5f, 0.5f) * CellLength;
        CenterCellPosition = float3(XZ.x, TerrianHeight + 0.5f * CellLength, XZ.y);
    }
    else if (DispatchThreadID.y == 1)
    {
        CenterVelocity = TopCellVelocity_R[DispatchThreadID.xz];
        float2 XZ = DispatchThreadID.xz * CellLength + float2(0.5f, 0.5f) * CellLength;
        CenterCellPosition = float3(XZ.x, TallCellHeight - 0.5f * CellLength, XZ.y);
    }
    else
    {
        uint3 Index3D = DispatchThreadID - uint3(0, 2, 0);
        CenterVelocity = RegularCellVelocity_R[Index3D];
        CenterCellPosition = Index3D * CellLength + float3(0.5f, 0.5f, 0.5f) * CellLength;
    }
    
    float3 LeftVelocity = sampleTallCellGrid(CenterCellPosition, int3(-1, 0, 0) * CellLength, CenterVelocity);
    float3 RightVelocity = sampleTallCellGrid(CenterCellPosition, int3(1, 0, 0) * CellLength, CenterVelocity);
    float3 DownVelocity = sampleTallCellGrid(CenterCellPosition, int3(0, -1, 0) * CellLength, CenterVelocity);
    float3 UpVelocity = sampleTallCellGrid(CenterCellPosition, int3(0, 1, 0) * CellLength, CenterVelocity);
    float3 BackVelocity = sampleTallCellGrid(CenterCellPosition, int3(0, 0, -1) * CellLength, CenterVelocity);
    float3 FrontVelocity = sampleTallCellGrid(CenterCellPosition, int3(0, 0, 1) * CellLength, CenterVelocity);

    VectorB_RW[DispatchThreadID] = ((RightVelocity.x - LeftVelocity.x) + (UpVelocity.y - DownVelocity.y) + (FrontVelocity.z - BackVelocity.z)) / CellLength;
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void smooth(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void restrict(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    
}

[numthreads(THREAD_COUNT_1D, 1, 1)]
void prolong(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    
}