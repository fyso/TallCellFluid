#pragma kernel preScan
#pragma kernel postScan
#pragma use_dxc
#define MULTI_SPLIT_BLOCK_SIZE 512
#define MAX_WARP_COUNT 32
#define MAX_LANE_COUNT 128
#define MAX_BUCKET_COUNT 32

uint ElementCount;
uint BucketCount;
uint GroupCount;

StructuredBuffer<uint> Key_R;
StructuredBuffer<uint> Value_R;
RWStructuredBuffer<uint> KeyBack_RW;
RWStructuredBuffer<uint> ValueBack_RW;
RWStructuredBuffer<uint3> DEBUG;

StructuredBuffer<uint> WarpLevelHistogramOffset_R;
RWStructuredBuffer<uint> WarpLevelHistogram_RW;

groupshared uint LocalWarpLevelHistogram[MAX_LANE_COUNT * MAX_BUCKET_COUNT];
groupshared uint LocalOffset[MULTI_SPLIT_BLOCK_SIZE];
groupshared uint LocalWarpSum[16];

uint4 Mask(uint4 vInput, uint vCount)
{
    uint MainIndex = vCount / 32;
    uint Pad = vCount % 32;
    vInput[MainIndex] &= (0XFFFFFFFF >> (32 - Pad - 1));
    for (int c = 0; c < MainIndex; c++)
    {
        vInput[c] = 0;
    }
    return vInput;
}

uint CountBits(uint4 vInput)
{
    uint4 CurrBucketCount = countbits(vInput);
    return CurrBucketCount.r + CurrBucketCount.g + CurrBucketCount.b + CurrBucketCount.a;
}

[numthreads(MULTI_SPLIT_BLOCK_SIZE, 1, 1)]
void preScan(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * MULTI_SPLIT_BLOCK_SIZE;
    
    uint CurrBucket = BucketCount - 1;
    if (i < ElementCount)
        CurrBucket = Key_R[i];
    
    uint CurrLaneIndex = WaveGetLaneIndex();
    uint CurrLaneCount = WaveGetLaneCount();
    
    uint CeilElementCount = ceil((float) ElementCount / CurrLaneCount) * CurrLaneCount;
    
    uint CurrWarpIndex = ThreadIdx / CurrLaneCount;
    uint PrevBlockWarpCount = GroupIdx == 0 ? 0 : ceil((float) MULTI_SPLIT_BLOCK_SIZE / CurrLaneCount);
    uint CurrBlockWarpCount = GroupIdx == GroupCount - 1 ? ceil((float) (CeilElementCount - GroupIdx * MULTI_SPLIT_BLOCK_SIZE) / CurrLaneCount) : ceil((float) MULTI_SPLIT_BLOCK_SIZE / CurrLaneCount);

    uint4 BallotResultBitCount = 0;
    for (int c = 0; c < BucketCount; c++)
    {
        uint4 BallotResult = WaveActiveBallot(c == CurrBucket);
        if (c == CurrBucket)
        {
            BallotResultBitCount = BallotResult;
            LocalWarpLevelHistogram[CurrBucket * CurrBlockWarpCount + CurrWarpIndex] = CountBits(BallotResult);
        }
    }
    GroupMemoryBarrierWithGroupSync();
    
    DEBUG[i].x = BallotResultBitCount.r;
    DEBUG[i].y = CurrBucket;
    DEBUG[i].z = CurrBucket * CurrBlockWarpCount + CurrWarpIndex;
    
    if (ThreadIdx < CurrBlockWarpCount * BucketCount)
    {
        int WarpCount = ceil((float) CeilElementCount / CurrLaneCount);
        int WarpIndex = ThreadIdx % CurrBlockWarpCount;
        int Bucket = ThreadIdx / CurrBlockWarpCount;
        
        WarpLevelHistogram_RW[Bucket * WarpCount + GroupIdx * PrevBlockWarpCount + WarpIndex] = LocalWarpLevelHistogram[ThreadIdx];
    }
}

groupshared uint LocalNoResignWarpLevelHistogram[MAX_LANE_COUNT * MAX_BUCKET_COUNT];
[numthreads(MULTI_SPLIT_BLOCK_SIZE, 1, 1)]
void postScan(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * MULTI_SPLIT_BLOCK_SIZE;
    
    uint CurrBucket = BucketCount - 1;
    if (i < ElementCount)
        CurrBucket = Key_R[i];
    
    uint CurrLaneIndex = WaveGetLaneIndex();
    uint CurrLaneCount = WaveGetLaneCount();
    
    uint CeilElementCount = ceil((float) ElementCount / CurrLaneCount) * CurrLaneCount;
    
    uint CurrWarpIndex = ThreadIdx / CurrLaneCount;
    uint PrevBlockWarpCount = GroupIdx == 0 ? 0 : ceil((float) MULTI_SPLIT_BLOCK_SIZE / CurrLaneCount);
    uint CurrBlockWarpCount = GroupIdx == GroupCount - 1 ? 
        ceil((float) (CeilElementCount - GroupIdx * MULTI_SPLIT_BLOCK_SIZE) / CurrLaneCount) : 
        ceil((float) MULTI_SPLIT_BLOCK_SIZE / CurrLaneCount);
    
    //local histogram and local offset
    uint4 CurrBucketMask;
    for (int c = 0; c < BucketCount; c++)
    {
        uint4 BallotResult = WaveActiveBallot(CurrBucket == c);
        if (CurrBucket == c)
            LocalNoResignWarpLevelHistogram[CurrWarpIndex * CurrLaneCount + c] = CountBits(BallotResult);
        
        if(CurrBucket == c)
        {
            CurrBucketMask = BallotResult;
        }
    }
    CurrBucketMask = Mask(CurrBucketMask, CurrLaneIndex);
    LocalOffset[ThreadIdx] = CountBits(CurrBucketMask) - 1;
    GroupMemoryBarrierWithGroupSync();
    
    //new index
    uint InWarpOffset = LocalOffset[ThreadIdx];
    
    uint WarpCount = ceil((float) CeilElementCount / CurrLaneCount);
    uint GlobalOffset = WarpLevelHistogramOffset_R[CurrBucket * WarpCount + GroupIdx * PrevBlockWarpCount + CurrWarpIndex];
    
    uint NewIndex = GlobalOffset + InWarpOffset;
    
    if (i >= ElementCount)
        return;
    
    KeyBack_RW[NewIndex] = Key_R[i];
    ValueBack_RW[NewIndex] = Value_R[i];
}